#if TARGET_OS_SIMULATOR
// Headers for Simulator
// Generated by Apple Swift version 5.1.3 (swiftlang-1100.0.282.1 clang-1100.0.33.15)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreGraphics;
@import Foundation;
@import LPAMS;
@import LPInfra;
@import ObjectiveC;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="LPMessagingSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif


SWIFT_PROTOCOL("_TtP14LPMessagingSDK39ConversationViewControllerAgentDelegate_")
@protocol ConversationViewControllerAgentDelegate
@optional
- (void)agentDidChangeUserInputText:(NSString * _Nonnull)text;
@end

@protocol LPMessagingAPIDelegate;
@class LPUser;
@protocol LPMessagingSDKNotificationDelegate;
@class LPCampaignInfo;
@protocol ConversationParamProtocol;
@class LPAuthenticationParams;
@class LPBrandEntity;
@class LPConversationEntity;
@class LPDialogEntity;
@class LPMessageEntity;
@class NSError;
@class CSATModel;
@class LPWelcomeMessage;
@class UploadInfo;
@class LPFileEntity;
@class RequestSwiftURL;
@class Ring;
@class LPFormEntity;
@class LPLinkPreviewEntity;
@class LPWebSocket;
@class UIImage;
@class LPConversationHistoryControlParam;
@class LPUserEntity;

SWIFT_CLASS("_TtC14LPMessagingSDK14LPMessagingAPI")
@interface LPMessagingAPI : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Initialize all underlying layers of the SDK.
///
/// returns:
/// Bool if initialization is successful
+ (BOOL)initializeAPI SWIFT_WARN_UNUSED_RESULT;
/// Set LPMessagingAPIDelegate implementor
+ (void)setDelegate:(id <LPMessagingAPIDelegate> _Nonnull)delegate;
/// Remove LPMessagingAPIDelegate implementor
+ (void)removeDelegate:(id <LPMessagingAPIDelegate> _Nonnull)delegate;
/// This method sets user details for the consumer of a brand.
/// The user object is in Type of LPUser which includes all the user details.
/// Additional paramaters:
/// <brandID> is the brand of the related user.
/// If the SDK is not connected, it’ll save the last user for each brand, until connected.
+ (void)setUserProfileWithDetails:(LPUser * _Nonnull)lpuser brandID:(NSString * _Nonnull)brandID;
/// This method registers the host app in the SDK Pusher service in order to be able to receive push notification in messaging.
/// Optional paramaters:
/// <notificationDelegate> is the implementer of LPMessagingSDKNotificationDelegate.
/// <alternateBundleID> is a value for using in order to let the Pusher service to identify the host app with this bundle identifier.
+ (void)registerPushNotificationsWithToken:(NSData * _Nonnull)token notificationDelegate:(id <LPMessagingSDKNotificationDelegate> _Nullable)notificationDelegate alternateBundleID:(NSString * _Nullable)alternateBundleID;
/// This method created ConversationParamProtocol of Brand query type.
+ (id <ConversationParamProtocol> _Nonnull)getConversationBrandQuery:(NSString * _Nonnull)brandID campaignInfo:(LPCampaignInfo * _Nullable)campaignInfo SWIFT_WARN_UNUSED_RESULT;
/// This method created ConversationParamProtocol of Consumer and Skill query type.
+ (id <ConversationParamProtocol> _Nonnull)getConversationConsumerQuery:(NSString * _Nullable)consumerID brandID:(NSString * _Nonnull)brandID agentToken:(NSString * _Nonnull)agentToken SWIFT_WARN_UNUSED_RESULT;
/// This method checks for an active(Open/Created) conversation according to conversation query.
/// Return value:
/// True - there is an active conversation.
/// False - there is no active conversation.
+ (BOOL)checkActiveConversation:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// This method checks if the active conversation of a conversation query marked as Urgent.
/// Return value:
/// True - conversation is marked as Urgent.
/// False - conversation is not marked as Urgent.
+ (BOOL)isUrgent:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// This method marks the active conversation of a conversation query as Urgent.
+ (void)changeUrgentState:(id <ConversationParamProtocol> _Nonnull)conversationQuery isUrgent:(BOOL)isUrgent;
/// This method ends the active conversation if exists.
+ (void)resolveConversationForConversationQuery:(id <ConversationParamProtocol> _Nonnull)conversationQuery;
/// This methods returns the assigned agent of the active or the latest closed conversation, if exists.
+ (LPUser * _Nullable)getAssignedAgent:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// This method determines wether a brandID is Ready.
/// Ready means that the brand is connected and conversation can be proccessed.
+ (BOOL)isBrandReady:(NSString * _Nonnull)brandID SWIFT_WARN_UNUSED_RESULT;
/// This method returns the SDK version.
+ (NSString * _Nullable)getSDKVersion SWIFT_WARN_UNUSED_RESULT;
/// Reset last saved scroll position of the conversation screen
+ (void)resetConversationScreenSavedScrollPosition;
/// Get inActive time in second from the user last touch on screen
///
/// returns:
/// TimeInterval (Double)
+ (NSTimeInterval)getInactiveUserInteractionTimeInterval:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// Appends content to the message text field
/// \param text Text to append
///
+ (void)addContentToMessageWithText:(NSString * _Nonnull)text;
/// This method overrides the state of the AMS state machine for a conversation query
/// \param conversationQuery used to identify the related brand
///
/// \param state the new state to be updated
///
+ (void)updateAMSState:(id <ConversationParamProtocol> _Nonnull)conversationQuery state:(enum AMSState)state;
/// Perform connect to socket for conversationQuery
/// @param:
/// <ul>
///   <li>
///     optional ready completion which will be called after the socket is connected
///   </li>
/// </ul>
+ (void)connectToSocket:(id <ConversationParamProtocol> _Nonnull)conversationQuery readyCompletion:(void (^ _Nullable)(void))readyCompletion;
/// Perform reconnect to socket for conversationQuery:
/// <ul>
///   <li>
///     Remove the websocket handler
///   </li>
///   <li>
///     connect to socket
///     @param:
///   </li>
///   <li>
///     optional ready completion which will be called after the socket is connected
///   </li>
///   <li>
///     optional an LPAuthenticationParams object to determine the properties of an authenticated connection. LPAuthenticationParams supports Code Flow login or Implicit Flow login.
///   </li>
/// </ul>
+ (void)reconnectToSocket:(id <ConversationParamProtocol> _Nonnull)conversationQuery authenticationParams:(LPAuthenticationParams * _Nonnull)authenticationParams readyCompletion:(void (^ _Nullable)(void))readyCompletion;
/// Perform disconnect from socket for conversationQuery.
/// You can choose to disconnect the socket aftet delay of predefined time
/// \param conversationQuery conversationQuery where to socket belongs to
///
/// \param shouldUseDelay determines whether to keep socket open for delay
///
+ (void)disconnectSocket:(id <ConversationParamProtocol> _Nonnull)conversationQuery;
/// Clear history of all closed conversations and their messages from the database.
/// This method is allowed only if there is no active/open conversation.
+ (BOOL)clearHistory:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// Delete all conversations and their messages from the database, which older than X months.
/// The number of months allowed is defined in LPConfig with attribute: deleteClosedConversationOlderThanMonths
+ (void)deleteOldConversations;
/// Create new conversation instance
+ (LPConversationEntity * _Nonnull)createConversation:(LPBrandEntity * _Nonnull)brand SWIFT_WARN_UNUSED_RESULT;
/// Send message from a Message instance related to an owner conversation
+ (void)sendMessageInDialog:(LPDialogEntity * _Nonnull)dialog message:(LPMessageEntity * _Nonnull)message completion:(void (^ _Nonnull)(LPMessageEntity * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Send message from a text string related to an owner conversation
/// This method will create new Message instance in the database.
/// Messages might be masked depending on regex and masking from LPConfig
+ (void)sendMessageInDialog:(LPDialogEntity * _Nonnull)dialog text:(NSString * _Nonnull)text completion:(void (^ _Nonnull)(LPMessageEntity * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Resolve/End a conversation from the user side
+ (void)resolveConversation:(LPConversationEntity * _Nonnull)conversation;
/// Request to change the conversation urgency status to on/off
+ (BOOL)requestUrgentResponse:(LPConversationEntity * _Nonnull)conversation urgent:(BOOL)urgent SWIFT_WARN_UNUSED_RESULT;
/// Retreive new messages from server for an owner converation
+ (void)retrieveNewMessagesForConversation:(LPConversationEntity * _Nonnull)conversation completion:(void (^ _Nullable)(NSArray<LPMessageEntity *> * _Nonnull))completion failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
/// Send CSAT to the server for an owner conversation (submit or skipped)
/// CSAT model is based on: rate of the csat, resolutionConfirmation toggle and wether csat is skipped or not
+ (void)sendCSAT:(LPConversationEntity * _Nonnull)conversation csat:(CSATModel * _Nonnull)csat;
/// Subscribe for exConversation notifications per for brandID
/// Use last updated time from the saved subscription times dictionary
/// Note: if there is an existing previous subscriptionID, unregister it before registering new one.
+ (void)subscribeConversationNotifications:(NSString * _Nonnull)brandID userID:(NSString * _Nonnull)userID socketType:(enum SocketType)socketType completion:(void (^ _Nullable)(NSString * _Nonnull))completion failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
/// Unsubscribe from exConversation notifications per brandID for subscriptionID
+ (void)unsubscribeConversationNotifications:(NSString * _Nonnull)brandID subscriptionID:(NSString * _Nonnull)subscriptionID;
/// Subscribe to routing tasks notification in order to get new rings for Agent
/// \param brandID brandID to subscribe for
///
/// \param agentID agentID to get new rings for
///
/// \param completion completion with subscriptionID
///
/// \param failure failure
///
+ (void)subscribeRoutingTasks:(NSString * _Nonnull)brandID agentID:(NSString * _Nonnull)agentID completion:(void (^ _Nullable)(NSString * _Nonnull))completion failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
/// Determines whether history query messages already fecthced
+ (BOOL)didFetchHistoryMessagingEventNotifications SWIFT_WARN_UNUSED_RESULT;
/// Determines whether history query messages is now being fetched
+ (BOOL)isFetchingHistoryMessages SWIFT_WARN_UNUSED_RESULT;
/// Determines the name of the assigned agent that should be presented in UI areas.
/// If assigned agent exists and has a nickname - return it. Otherwise, return nil.
/// If nil is returned, it should be handled according to UI area
+ (NSString * _Nullable)agentNameUIRepresentation:(LPConversationEntity * _Nullable)conversation SWIFT_WARN_UNUSED_RESULT;
/// Create resolved system message for dialog, according to resolving side
/// Timestamp - when agent resolved we take the timestamp from server, when consumer resolved we take now.
+ (LPMessageEntity * _Nullable)createResolveLocalMessage:(LPDialogEntity * _Nonnull)dialog endTime:(NSDate * _Nonnull)endTime SWIFT_WARN_UNUSED_RESULT;
/// Creates local system message for masked message according to the current masking type:
/// \param conversation conversation that the message will be added to
///
/// \param isRealTimeMasking should the system message text represent real time masking or client side masking
///
///
/// returns:
/// local masked message, nil if failed
+ (LPMessageEntity * _Nullable)createMessageMaskedLocalMessage:(LPConversationEntity * _Nonnull)conversation isRealTimeMasking:(BOOL)isRealTimeMasking SWIFT_WARN_UNUSED_RESULT;
+ (LPMessageEntity * _Nullable)createWelcomeLocalMessage:(LPDialogEntity * _Nonnull)dialog overrideTime:(NSDate * _Nonnull)overrideTime SWIFT_WARN_UNUSED_RESULT SWIFT_AVAILABILITY(ios,deprecated=12.0.0,obsoleted=14.0.0,message="Use createWelcomeLocalMessage(_ dialog: Dialog, welcomeMessage: LPWelcomeMessage,  overrideTime: Date = Date()) -> Message? instead");
+ (LPMessageEntity * _Nullable)createWelcomeLocalMessage:(LPDialogEntity * _Nonnull)dialog welcomeMessage:(LPWelcomeMessage * _Nonnull)welcomeMessage overrideTime:(NSDate * _Nonnull)overrideTime SWIFT_WARN_UNUSED_RESULT;
/// Upload file from upload info object
/// \param uploadInfo Includes all necessary info about required file to upload
///
/// \param conversation conversation that the file will be added to
///
/// \param completion complition handler
///
/// \param failure failure handler
///
+ (void)uploadFileFromInfoWithUploadInfo:(UploadInfo * _Nonnull)uploadInfo dialog:(LPDialogEntity * _Nonnull)dialog completion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Upload file that is saved on disk and send message (mainly for failed messages)
+ (void)uploadFileFromDiskWithMessage:(LPMessageEntity * _Nonnull)message dialog:(LPDialogEntity * _Nonnull)dialog completion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Downloads a file from Swift server and returns an image to show
+ (void)downloadFileWithDialog:(LPDialogEntity * _Nonnull)dialog file:(LPFileEntity * _Nonnull)file completion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Requests the AMS for an upload url for swift server
+ (void)requestUploadURLWithDialog:(LPDialogEntity * _Nonnull)dialog fileSize:(double)fileSize fileExtention:(NSString * _Nonnull)fileExtention completion:(void (^ _Nonnull)(RequestSwiftURL * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Requests the AMS for a download url from swift server
+ (void)requestDownloadURLWithDialog:(LPDialogEntity * _Nonnull)dialog file:(LPFileEntity * _Nonnull)file completion:(void (^ _Nonnull)(id _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Clear all singleton managers with their properties from memory.
/// This method will release any data objects and data structures.
+ (void)clearManagers;
+ (void)acceptRing:(Ring * _Nonnull)ring agentToken:(NSString * _Nonnull)agentToken completion:(void (^ _Nonnull)(LPConversationEntity * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
+ (void)backToQueue:(NSString * _Nonnull)userID conversation:(LPConversationEntity * _Nonnull)conversation completion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
+ (void)subscribeAgentState:(id <ConversationParamProtocol> _Nonnull)conversationQuery agentID:(NSString * _Nonnull)agentID completion:(void (^ _Nullable)(id _Nonnull))completion failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
+ (void)setAgentState:(id <ConversationParamProtocol> _Nonnull)conversationQuery agentID:(NSString * _Nonnull)agentID channels:(NSArray<NSString *> * _Nullable)channels availability:(NSString * _Nonnull)availability description:(NSString * _Nonnull)description completion:(void (^ _Nullable)(id _Nonnull))completion failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
+ (void)agentRequestConversation:(id <ConversationParamProtocol> _Nonnull)conversationQuery context:(NSDictionary<NSString *, NSString *> * _Nonnull)context ttrDefName:(NSString * _Nonnull)ttrDefName channelType:(NSString * _Nonnull)channelType consumerId:(NSString * _Nonnull)consumerId completion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
+ (NSArray<NSString *> * _Nonnull)getAllConsumersID SWIFT_WARN_UNUSED_RESULT;
/// Prepare secure form to be open in a webview
/// This method generates read and write OTK from UMS and build URL to be used for PCI GW
/// \param form form object to get the url for
///
/// \param completion completion block when the form is ready - url and token are valid
///
/// \param failure failure block with error
///
+ (void)prepareSecureFormWithForm:(LPFormEntity * _Nonnull)form completion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Gets link preview messages with a state of “loading”
///
/// returns:
/// Optional array of messages
+ (NSArray<LPMessageEntity *> * _Nullable)getLoadingStructuredContentMessages SWIFT_WARN_UNUSED_RESULT;
/// Gets link preview boards with a state of “loading”
///
/// returns:
/// Optional array of custom boards
+ (NSArray<LPLinkPreviewEntity *> * _Nullable)getLoadingStructuredContentCustomItems SWIFT_WARN_UNUSED_RESULT;
/// Determine if the brand has an active controller/bot in his conversations
/// \param brandID brandID owner of the controller
///
///
/// returns:
/// true if active else false
+ (BOOL)hasActiveController:(NSString * _Nonnull)brandID SWIFT_WARN_UNUSED_RESULT;
/// Get current WebSocket (LPWebSocket) for brand if exists
+ (LPWebSocket * _Nullable)getSocket:(NSString * _Nonnull)brandID SWIFT_WARN_UNUSED_RESULT;
/// Open and reconnect each WebSocket in the web sockets map.
+ (void)openAllSockets;
/// Open and reconnect single WebSocket and assign to web sockets map.
/// This method creates new WebSocket instances based on the previous ones because we can’t reuse WebSocket instances.
+ (void)openSocket:(LPWebSocket * _Nonnull)webSocket;
/// Close all sockets in the web sockets map
/// We DON’T remove the web sockets from the map in order to be able to re-create web socket from a previous one
+ (void)closeAllSockets;
/// Create file from UploadInfo and return when ready if succeeded, invoke error otherwise.
/// Using GeneratePhotoOperation
+ (void)prepareFileWithUploadInfo:(UploadInfo * _Nonnull)uploadInfo fileReadyCompletion:(void (^ _Nonnull)(LPFileEntity * _Nonnull))fileReadyCompletion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Upload File to Swift server and AMS using file operation
+ (void)uploadFileWithFile:(LPFileEntity * _Nonnull)file uploadRelativePath:(NSString * _Nonnull)uploadRelativePath tempURLSig:(NSString * _Nonnull)tempURLSig tempURLExpiry:(NSString * _Nonnull)tempURLExpiry completion:(void (^ _Nonnull)(LPFileEntity * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Get full photo image from disk using file path.
/// If file path is invalid, an error will be invoked.
/// If file does not exist on disk, function will return nil for image.
+ (void)getPhotoFromFileWithFile:(LPFileEntity * _Nonnull)file completion:(void (^ _Nonnull)(UIImage * _Nullable))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Ensure that file has been saved to disk, and return that entity.
/// If file path is invalid, an error will be invoked.
/// If file has does not exist on disk, function will return nil for fileEntity
+ (void)getFileFromFileEntityWithFileEntity:(LPFileEntity * _Nonnull)fileEntity completion:(void (^ _Nonnull)(LPFileEntity * _Nullable))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Get full thumbnail image from disk using file path.
/// If image fails to created or file path is invalid, an error will be invoked.
+ (void)getThumbnailFromFileWithFile:(LPFileEntity * _Nonnull)file completion:(void (^ _Nonnull)(UIImage * _Nullable))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Get thumbnail for the files in file sharing from custom configurations.
/// If custom configurations is nil, provide the thumbnail based on the files UTI
/// \param file local file to get the thumbnail from
///
- (UIImage * _Nonnull)getThumbnailForFileTypeWithFile:(LPFileEntity * _Nonnull)file SWIFT_WARN_UNUSED_RESULT;
/// Returns a base64 string representation of the file’s thumbnail
+ (void)getBase64ThumbnailStringWithFile:(LPFileEntity * _Nonnull)file completion:(SWIFT_NOESCAPE void (^ _Nonnull)(NSString * _Nonnull))completion failure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Returns a base64 string representation of blank thumbnail file
+ (void)getBase64BlankThumbnailStringWithCompletion:(SWIFT_NOESCAPE void (^ _Nonnull)(NSString * _Nonnull))completion failure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Deletes file and thumbnail from disk
+ (void)deleteFileFromDiskWithFile:(LPFileEntity * _Nonnull)file;
/// Deleting the main directory with all files in it from the disk
/// This method is performed in background thread
+ (void)deleteAllFilesFromDiskWithCompletion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// This method delete number of files that exceeded maxNumberOfSavedFilesOnDisk from configuration.
/// The files will be get deleted accoring to FIFO methodology.
/// This method is performed in background thread and only of the photo sharing feature is enabled
+ (void)handleMaxNumberOfSavedFilesOnDisk;
/// Get Brand object for account ID
/// If there is no brand object for the account ID, a new brand will be created in DB
+ (LPBrandEntity * _Nonnull)getOrCreateBrandByAccountID:(NSString * _Nonnull)accountID SWIFT_WARN_UNUSED_RESULT;
/// Clear a single conversation and its assoicated messages and files (also from the disk)
/// Return TRUE if the conversation and its messages was deleted.
/// Return FALSE if the conversation or one if its messages were failed to delete.
+ (BOOL)clearConversationFromDB:(LPConversationEntity * _Nonnull)conversation SWIFT_WARN_UNUSED_RESULT;
/// Get all closed conversations from database
+ (NSArray<LPConversationEntity *> * _Nullable)getAllClosedConversations:(NSDate * _Nullable)olderThanDate SWIFT_WARN_UNUSED_RESULT;
/// Get all conversations from DB sorted by creation date (first object is the latest conversation)
/// If includeQueriedOnly parameter is false, only new conversations or conversations which messages should not be queried, will be returned
+ (NSArray<LPConversationEntity *> * _Nonnull)getConversationsSortedByDate:(id <ConversationParamProtocol> _Nonnull)query conversationHistoryControlParam:(LPConversationHistoryControlParam * _Nullable)conversationHistoryControlParam SWIFT_WARN_UNUSED_RESULT;
/// Attach completion block which is being invoken when the Consumer (My) User is retrieved
+ (void)attachMyUserCompletion:(void (^ _Nonnull)(NSString * _Nonnull))completion;
/// This method fetch user from the database.
/// <ul>
///   <li>
///     Fetch user data from database
///   </li>
///   <li>
///     If user does not exist, a nil will be returned
///   </li>
/// </ul>
+ (LPUserEntity * _Nullable)getUserFromDatabaseWithUserID:(NSString * _Nonnull)userID SWIFT_WARN_UNUSED_RESULT;
/// Fetching the user profile (consumer or agent) from server and update in database received details and current date as lastUpdated
/// Fetch will be performed in the following cases:
/// <ol>
///   <li>
///     User was never fetched
///   </li>
///   <li>
///     User was not fetched in current app run
///   </li>
///   <li>
///     User was not fetched for more than 24Hrs
///   </li>
/// </ol>
+ (void)refreshUserProfileWithBrandID:(NSString * _Nonnull)brandID user:(LPUserEntity * _Nonnull)user;
/// Set token for Pusher service in order to be able to receive remote push notifications
/// Optional - alternateBundleID, set custom bundle ID for Pusher with for the token
+ (void)setPusherTokenWithToken:(NSData * _Nonnull)token alternateBundleID:(NSString * _Nullable)alternateBundleID;
/// Set token for VoIP Pusher service in order to be able to receive remote calls
/// Optional - alternateBundleID, set custom bundle ID for Pusher with for the token
+ (void)setPusherVoipTokenWithToken:(NSData * _Nonnull)token alternateBundleID:(NSString * _Nullable)alternateBundleID;
/// Register pusher with push notification token received from APNS (Apple).
/// Before registering the Pusher, we make sure have the following params:
/// <ul>
///   <li>
///     Consumer UserID
///   </li>
///   <li>
///     Push Token from Apple
///   </li>
///   <li>
///     CSDS Domain for Pusher
///   </li>
///   <li>
///     Account (brand account)
///     When all params availble - peform register
///   </li>
/// </ul>
+ (void)registerPusher:(LPBrandEntity * _Nonnull)brand;
/// Get unread message badge counter
/// There are two options to get this counter:
/// <ol>
///   <li>
///     If the time condition is met we are prefoming a REST request to get it from pusher
///   </li>
///   <li>
///     otherwise, return the cached number we have
///   </li>
/// </ol>
/// note:
/// this method requires the user to accept/allow push notifications (dependancy of pusher)
/// \param conversationQuery conversationQuery: used to identify the related brand
///
/// \param completion called once the operation ends sucessfully
///
/// \param failure called once the operation failed
///
+ (void)getUnreadMessagesCount:(id <ConversationParamProtocol> _Nonnull)conversationQuery completion:(void (^ _Nonnull)(NSInteger))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Get unread message badge counter
/// \param brandID the account number for the brand
///
/// \param completion called once the operation ends sucessfully
///
/// \param failure called once the operation failed
///
+ (void)getUnreadMessagesCountWithBrandID:(NSString * _Nonnull)brandID completion:(void (^ _Nonnull)(NSInteger))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Unregister pusher.
/// Before unregistering the Pusher, we make sure we have the following params:
/// <ul>
///   <li>
///     Consumer UserID
///   </li>
///   <li>
///     CSDS Domain for Pusher
///   </li>
///   <li>
///     Account (brand account)
///     When all params availble - peform unregister
///   </li>
/// </ul>
+ (void)unregisterPusher:(LPBrandEntity * _Nonnull)brand completion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Get CSDS domain for accountID and service name
/// This method get all the CSDS domains and look for the specific domain per service
+ (void)getCSDSDomain:(NSString * _Nonnull)accountID serviceName:(NSString * _Nonnull)serviceName completion:(void (^ _Nonnull)(NSString * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Get All CSDS Service Domains
/// This method uses cache to store and fetch services domains. For every new app session, the CSDS cache will get updated from server
/// Completion blocks will be invoked once there is a stored cache or after the request from the server completed
/// \param accountID accountID to get all services for
///
/// \param completion completion block with the response domains from server
///
/// \param failure failure block with error which will be invoked if server request failed
///
+ (void)getAllCSDSDomains:(NSString * _Nonnull)accountID completion:(void (^ _Nonnull)(NSArray<NSDictionary<NSString *, id> *> * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Set image for URL in images cache
+ (void)setImageByURL:(UIImage * _Nonnull)image url:(NSString * _Nonnull)url;
/// Get image by URL from images cache
+ (UIImage * _Nullable)getImageByURL:(NSString * _Nonnull)url SWIFT_WARN_UNUSED_RESULT;
/// Determine if network is reachable using reachability framework
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL isNetworkReachable;)
+ (BOOL)isNetworkReachable SWIFT_WARN_UNUSED_RESULT;
/// Get open conversation from DB
///
/// returns:
/// an open conversation if exists - if none, returns nil
+ (LPConversationEntity * _Nullable)getOpenConveration SWIFT_WARN_UNUSED_RESULT;
/// Get array of consumer ids that are related to messages that contain a certain string
/// \param text The string that the messages should contain
///
///
/// returns:
/// Array of consumer ids or nil if none found
+ (NSArray<NSString *> * _Nullable)getConsumerIdsRelatedToMessagesThatContains:(NSString * _Nonnull)text SWIFT_WARN_UNUSED_RESULT;
@end


/// We use this protocol as a mirror for LPAMSFacadeDelegate When setting delegate for LPMessagingAPIDelegate we just pass it as LPAMSFacadeDelegate to LPAMSFacade. Note: Before adding new methods this LPMessagingAPIDelegate but not to LPAMSFacadeDelegate, you should Implement LPAMSFacadeDelegate in this class and then call the delegate of LPMessagingAPIDelegate
SWIFT_PROTOCOL("_TtP14LPMessagingSDK22LPMessagingAPIDelegate_")
@protocol LPMessagingAPIDelegate <LPAMSFacadeDelegate>
@end

@protocol LPMessagingSDKdelegate;
@class LPMonitoringInitParams;
@class UIViewController;
@class LPConversationViewParams;
@class UIBarButtonItem;
@class LPLog;

SWIFT_CLASS("_TtC14LPMessagingSDK14LPMessagingSDK")
@interface LPMessagingSDK : NSObject
@property (nonatomic, weak) id <LPMessagingSDKdelegate> _Nullable delegate;
@property (nonatomic, weak) id <LPMessagingSDKNotificationDelegate> _Nullable notificationDelegate;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) LPMessagingSDK * _Nonnull instance;)
+ (LPMessagingSDK * _Nonnull)instance SWIFT_WARN_UNUSED_RESULT;
/// Initialize the SDK and all of its components.
/// Optional paramaters:
/// <brandID> of the host app.
/// This method throws an error/return false with with an error, in case the initialization failed.
- (BOOL)initialize:(NSString * _Nullable)brandID monitoringInitParams:(LPMonitoringInitParams * _Nullable)monitoringInitParams error:(NSError * _Nullable * _Nullable)error;
/// Show conversation view for conversation query.
/// This method starts the conversation and show all the existing messages it exist.
/// Optional paramaters:
/// <authenticationCode> to use an an authenticated users.
/// <containerViewController> the containter which presents the conversation view as a child View Controller.
/// DEPRECATED - Use showConversation(_ conversationViewParams: LPConversationViewParams) instead
- (void)showConversation:(id <ConversationParamProtocol> _Nonnull)conversationQuery authenticationCode:(NSString * _Nullable)authenticationCode containerViewController:(UIViewController * _Nullable)containerViewController SWIFT_AVAILABILITY(ios,deprecated=9.3.5,obsoleted=14.0.0,message="Use showConversation(_ conversationViewParams: LPConversationViewParams) instead");
/// Show Conversation view and starts the conversation and show all the existing messages it exist.
/// \param conversationViewParams an LPConversationViewParams object to determine the properties of the views. Such as Container or Window or if ViewOnly.
///
/// \param authenticationParams an optional LPAuthenticationParams object to determine the properties of an authenticated connection. If using authenticate connection, this paramater must
/// be passed. LPAuthenticationParams supports Code Flow login or Implicit Flow login.
///
- (void)showConversation:(LPConversationViewParams * _Nonnull)conversationViewParams authenticationParams:(LPAuthenticationParams * _Nullable)authenticationParams;
/// Remove conversation view for conversation query from its container or window view.
/// This method ends the conversation’s connection.
- (void)removeConversation:(id <ConversationParamProtocol> _Nonnull)conversationQuery;
/// This method reconnects the conversation’s connection for conversation query.
/// Reconnect open related webSockets and sync the converstion with its latest updates.
/// Additional paramaters:
/// <authenticationCode> to use an an authenticated users.
- (void)reconnect:(id <ConversationParamProtocol> _Nonnull)conversationQuery authenticationCode:(NSString * _Nonnull)authenticationCode SWIFT_AVAILABILITY(ios,deprecated=9.3.5,obsoleted=14.0.0,message="Use reconnect(_ conversationQuery: ConversationParamProtocol, authenticationParams: LPAuthenticationParams) instead");
/// This method reconnects the conversation’s connection for conversation query.
/// Reconnect open related webSockets and sync the converstion with its latest updates.
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     conversationQuery: conversationQuery of ConversationParamProtocol
///   </li>
///   <li>
///     authenticationParams: an LPAuthenticationParams object to determine the properties of an authenticated connection. LPAuthenticationParams supports Code Flow login or Implicit Flow login.
///   </li>
/// </ul>
- (void)reconnect:(id <ConversationParamProtocol> _Nonnull)conversationQuery authenticationParams:(LPAuthenticationParams * _Nonnull)authenticationParams;
/// This method changes the state of the action menu of the conversation for brandID.
- (void)toggleChatActions:(NSString * _Nonnull)accountID sender:(UIBarButtonItem * _Nullable)sender;
/// This method sets user details for the consumer of a brand.
/// The user object is in Type of LPUser which includes all the user details.
/// Additional paramaters:
/// <brandID> is the brand of the related user.
/// If the SDK is not connected, it’ll save the last user for each brand, until connected.
- (void)setUserProfile:(LPUser * _Nonnull)lpuser brandID:(NSString * _Nonnull)brandID;
/// This method created ConversationParamProtocol of Brand query type.
/// ConversationParamProtocol represents a ’filter’ for the conversation screen, determining which of the conversations will be displayed in the following screens.
/// \param brandID brandID to request the conversation query for
///
/// \param campaignInfo an optional campaign info (LPCampaignInfo) to use advanced routing for the consumer. This object based on campaignID and engagementID
///
///
/// returns:
/// a new ConversationParamProtocol by type of BrandQuery
- (id <ConversationParamProtocol> _Nonnull)getConversationBrandQuery:(NSString * _Nonnull)brandID campaignInfo:(LPCampaignInfo * _Nullable)campaignInfo SWIFT_WARN_UNUSED_RESULT;
/// This method created ConversationParamProtocol of Consumer and Skill query type.
/// ConversationParamProtocol represents a ’filter’ for the conversation screen, determining which of the conversations will be displayed in the following screens.
/// \param consumerID consumerID to request the conversation query for
///
/// \param brandID brandID to request the conversation query for
///
/// \param agentToken a unique token for agent aka Agent Bearer
///
///
/// returns:
/// a new ConversationParamProtocol by type of ConsumerQuery
- (id <ConversationParamProtocol> _Nonnull)getConversationConsumerQuery:(NSString * _Nullable)consumerID brandID:(NSString * _Nonnull)brandID agentToken:(NSString * _Nonnull)agentToken SWIFT_WARN_UNUSED_RESULT;
/// This method checks for an active(Open/Created) conversation according to conversation query.
/// Return value:
/// True - there is an active conversation.
/// False - there is no active conversation.
- (BOOL)checkActiveConversation:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// DEPRECATED - This method sets a custom image for the custom button in the conversation navigationBar.
/// Use customButtonImage instead
- (void)setCustomButton:(UIImage * _Nullable)image SWIFT_AVAILABILITY(ios,deprecated=9.3.5,obsoleted=14.0.0,message="configure the image using customButtonImage in LPConfig instead");
/// This method checks if the active conversation of a conversation query marked as Urgent.
/// Return value:
/// True - conversation is marked as Urgent.
/// False - conversation is not marked as Urgent.
- (BOOL)isUrgent:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// This method marks the active conversation of a conversation query as Urgent.
- (void)markAsUrgent:(id <ConversationParamProtocol> _Nonnull)conversationQuery;
/// This method dismisses the active conversation from Urgent to Normal.
- (void)dismissUrgent:(id <ConversationParamProtocol> _Nonnull)conversationQuery;
/// This method ends the active conversation if exists.
- (void)resolveConversation:(id <ConversationParamProtocol> _Nonnull)conversationQuery;
/// This methods returns the assigned agent of the active or the latest closed conversation, if exists.
- (LPUser * _Nullable)getAssignedAgent:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// This method determines wether a brandID is Ready.
/// Ready means that the brand is connected and conversation can be proccessed.
- (BOOL)isBrandReady:(NSString * _Nonnull)brandID SWIFT_WARN_UNUSED_RESULT;
/// This method returns the SDK version.
- (NSString * _Nullable)getSDKVersion SWIFT_WARN_UNUSED_RESULT;
/// Get Inactive time interval in seconds of the user last touch on screen. This interval applies to scroll/messaging/action menus and any other general action on the conversation screen.
/// If the screen is not active or the application is in background this api will return -1.
///
/// returns:
/// Inactive TimeInterval (Double)
- (NSTimeInterval)getInactiveUserInteractionTimeInterval:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// This method deletes all the messages and closed conversation of the related conversation query.
/// This method throws an error if the conversations history failed to cleared.
/// Note: clear history is allowed only if there is no open/active conversation related to the passed conversation query.
- (BOOL)clearHistory:(id <ConversationParamProtocol> _Nonnull)conversationQuery error:(NSError * _Nullable * _Nullable)error;
/// This method subscribes the host app to recieve log events from a specific log level and above.
/// Optionl log levels: TRACE, DEBUG, INFO, WARNING and ERROR.
/// The completion block will pass LPLog object which consists all the information for the log.
- (void)subscribeLogEvents:(enum LogLevel)logLevel logEvent:(void (^ _Nonnull)(LPLog * _Nonnull))logEvent;
/// Prints all localized string’s keys
- (void)printAllLocalizedKeys;
/// Prints the SDK supported languages
- (void)printSupportedLanguages;
/// Get all supported languages as Strings dictionary where:
/// Key - Locale key
/// Value - explicit language name (example: “English”, “Portuguese (Brazil)”, …)
- (NSDictionary<NSString *, NSString *> * _Nonnull)getAllSupportedLanguages SWIFT_WARN_UNUSED_RESULT;
/// Notifies the SDK that a push notification was tapped.
/// This method should be called immediately after the host app has determined that a notification was tapped.
/// For scroll behavior on push notification tapped, see LPConfig.conversationScrollConfiguration
- (void)setPushNotificationTapped;
@end




@interface LPMessagingSDK (SWIFT_EXTENSION(LPMessagingSDK))
- (void)initSocketForBrandID:(NSString * _Nonnull)brandID agentToken:(NSString * _Nonnull)agentToken readyCompletion:(void (^ _Nullable)(void))readyCompletion SWIFT_METHOD_FAMILY(none);
- (id <ConversationViewControllerAgentDelegate> _Nonnull)showAgentConversationWithConversationViewParams:(LPConversationViewParams * _Nonnull)conversationViewParams SWIFT_WARN_UNUSED_RESULT;
@end


@interface LPMessagingSDK (SWIFT_EXTENSION(LPMessagingSDK))
/// This method registers the host app in the SDK Pusher service in order to be able to receive push notification in messaging.
/// note:
/// If passing authentication params, this method will register immediately to Pusher, the registration will be performed when calling showConversation
/// \param token push device token data
///
/// \param notificationDelegate implementer of LPMessagingSDKNotificationDelegate.
///
/// \param alternateBundleID a value for using in order to let the Pusher service to identify the host app with this bundle identifier
///
/// \param authenticationParams an optional authentication param (LPAuthenticationParams) to be used for immediate Pusher registration
///
- (void)registerPushNotificationsWithToken:(NSData * _Nonnull)token notificationDelegate:(id <LPMessagingSDKNotificationDelegate> _Nullable)notificationDelegate alternateBundleID:(NSString * _Nullable)alternateBundleID authenticationParams:(LPAuthenticationParams * _Nullable)authenticationParams;
/// This method registers Voip the host app to SDK Pusher service
/// \param token push device token data
///
/// \param alternateBundleID a value for using in order to let the Pusher service to identify the host app with this bundle identifier
///
- (void)registerVoipPushNotificationsWithToken:(NSData * _Nonnull)token alternateBundleID:(NSString * _Nullable)alternateBundleID;
/// This method unregisters the host app from SDK Pusher service
/// \param brandId brand/account Identifier
///
- (void)unregisterPusherWithBrandId:(NSString * _Nonnull)brandId completion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Set token for Pusher service in order to be able to receive remote push notifications
/// \param token Data
///
/// \param alternateBundleID String? a custom bundle ID for Pusher with for the token
///
+ (void)setPusherTokenWithToken:(NSData * _Nonnull)token alternateBundleID:(NSString * _Nullable)alternateBundleID;
/// Set token for VoIP Pusher service in order to be able to receive remote calls
/// \param token Data
///
/// \param alternateBundleID String? a custom bundle ID for Pusher with for the token
///
+ (void)setPusherVoipTokenWithToken:(NSData * _Nonnull)token alternateBundleID:(NSString * _Nullable)alternateBundleID;
/// Get unread message badge counter
/// There are two options to get this counter:
/// <ol>
///   <li>
///     If the time condition is met we are prefoming a REST request to get it from pusher
///   </li>
///   <li>
///     otherwise, return the cached number we have
///   </li>
/// </ol>
/// note:
/// this method requires the user to accept/allow push notifications (dependancy of pusher)
/// \param conversationQuery conversationQuery: used to identify the related brand
///
/// \param completion called once the operation ends sucessfully
///
/// \param failure called once the operation failed
///
+ (void)getUnreadMessagesCount:(id <ConversationParamProtocol> _Nonnull)conversationQuery completion:(void (^ _Nonnull)(NSInteger))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Get unread message badge counter
/// \param brandID the account number for the brand
///
/// \param completion called once the operation ends sucessfully
///
/// \param failure called once the operation failed
///
+ (void)getUnreadMessagesCountWithBrandID:(NSString * _Nonnull)brandID completion:(void (^ _Nonnull)(NSInteger))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// This method passes a user info of a remote push notification to be handled by the SDK.
/// <ul>
///   <li>
///     Paramaters:
///     <ul>
///       <li>
///         userInfo: Dictionary
///       </li>
///     </ul>
///   </li>
/// </ul>
- (void)handlePush:(NSDictionary * _Nonnull)userInfo;
@end


@interface LPMessagingSDK (SWIFT_EXTENSION(LPMessagingSDK))
/// This method is a destructive method that is typically used stop and clear all the metadata of the SDK.
/// This method conducts the following:
/// Clears all SDK non-persistent data.
/// Stops all connections.
/// Remove Conversation View Controller
- (void)destruct;
/// This method is a destructive method that is typically used to clean a user’s data before a second user logs into the same device or just to logs the current user out.
/// This method conducts the following:
/// Unregisters from the push notification service.
/// Clears all SDK persistent data.
/// Cleans running operations (see <a href="consumer-experience-ios-sdk-destruct.html">destruct</a>{:target=”<em>blank”}).
/// Invocation of destruct() method
/// DEPRECATED - Use logout(completion: @escaping ()->(), failure: @escaping (</em> error: Error)->()) instead
- (void)logout SWIFT_AVAILABILITY(ios,deprecated=9.3.5,obsoleted=14.0.0,message="Use logout(completion: @escaping ()->(), failure: @escaping (_ error: Error)->()) instead");
/// This method is a destructive method that is typically used to clean a user’s data before a second user logs into the same device or just to logs the current user out.
/// This method conducts the following:
/// Unregisters from the push notification service.
/// Clears all SDK persistent data.
/// Cleans running operations (see <a href="consumer-experience-ios-sdk-destruct.html">destruct</a>{:target=”_blank”}).
/// Invocation of destruct() method
/// note:
/// this method should be called before any persistent clean up tasks are performed on host app
/// \param completion A completion block for successfully logout. Completion block will be invoked only if all logout steps succeeded.
///
/// \param failure A failure block with a specified error for logout failure. Failure block will be invoked if at least one of the logout steps has failed.
///
- (void)logoutWithCompletion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
@end

@class LPNotification;
@class UIView;

SWIFT_PROTOCOL("_TtP14LPMessagingSDK34LPMessagingSDKNotificationDelegate_")
@protocol LPMessagingSDKNotificationDelegate
@optional
- (void)LPMessagingSDKNotificationWithDidReceivePushNotification:(LPNotification * _Nonnull)notification;
- (BOOL)LPMessagingSDKNotificationWithShouldShowPushNotification:(LPNotification * _Nonnull)notification SWIFT_WARN_UNUSED_RESULT;
- (UIView * _Nonnull)LPMessagingSDKNotificationWithCustomLocalPushNotificationView:(LPNotification * _Nonnull)notification SWIFT_WARN_UNUSED_RESULT;
- (void)LPMessagingSDKNotificationWithNotificationTapped:(LPNotification * _Nonnull)notification;
@end


SWIFT_PROTOCOL("_TtP14LPMessagingSDK22LPMessagingSDKdelegate_")
@protocol LPMessagingSDKdelegate
@optional
- (void)LPMessagingSDKCustomButtonTapped;
- (void)LPMessagingSDKAgentDetails:(LPUser * _Nullable)agent;
- (void)LPMessagingSDKAgentAvatarTapped:(LPUser * _Nullable)agent;
- (void)LPMessagingSDKActionsMenuToggled:(BOOL)toggled;
- (void)LPMessagingSDKHasConnectionError:(NSString * _Nullable)error;
- (void)LPMessagingSDKCSATScoreSubmissionDidFinish:(NSString * _Nonnull)brandID rating:(NSInteger)rating;
- (UIView * _Nonnull)LPMessagingSDKCSATCustomTitleView:(NSString * _Nonnull)brandID SWIFT_WARN_UNUSED_RESULT;
- (void)LPMessagingSDKConversationCSATSkipped:(NSString * _Nullable)conversationID;
- (void)LPMessagingSDKUserDeniedPermission:(enum LPPermissionTypes)permissionType;
@required
- (void)LPMessagingSDKObseleteVersion:(NSError * _Nonnull)error;
- (void)LPMessagingSDKAuthenticationFailed:(NSError * _Nonnull)error;
- (void)LPMessagingSDKTokenExpired:(NSString * _Nonnull)brandID;
- (void)LPMessagingSDKError:(NSError * _Nonnull)error;
@optional
- (void)LPMessagingSDKConnectionRetriesFailed:(NSError * _Nonnull)error;
- (void)LPMessagingSDKAgentIsTypingStateChanged:(BOOL)isTyping;
- (void)LPMessagingSDKConversationStarted:(NSString * _Nullable)conversationID;
- (void)LPMessagingSDKConversationEnded:(NSString * _Nullable)conversationID SWIFT_AVAILABILITY(ios,deprecated=9.3.5,obsoleted=14.0.0,message="use LPMessagingSDKConversationEnded(_:closeReason) instead");
- (void)LPMessagingSDKConversationEnded:(NSString * _Nullable)conversationID closeReason:(enum LPConversationCloseReason)closeReason;
- (void)LPMessagingSDKConversationCSATDismissedOnSubmittion:(NSString * _Nullable)conversationID;
- (void)LPMessagingSDKConversationCSATDidLoad:(NSString * _Nullable)conversationID;
- (void)LPMessagingSDKConnectionStateChanged:(BOOL)isReady brandID:(NSString * _Nonnull)brandID;
- (void)LPMessagingSDKOffHoursStateChanged:(BOOL)isOffHours brandID:(NSString * _Nonnull)brandID;
- (void)LPMessagingSDKConversationViewControllerDidDismiss;
/// Called when the Cert pinning mechanism failed. The server trust was successfully evaluated but did not contain any of the configured public keys pins. or The server trust’s evaluation failed: the server’s certificate chain is not trusted.
/// \param error failure error reason
///
- (void)LPMessagingSDKCertPinningFailed:(NSError * _Nonnull)error;
/// Called the SDK registration for  LP Pusher service has been succeeded.
/// Pusher is the service that responsible for Remote Push Notifications routing and delivering from and to APNS.
- (void)LPMessagingSDKPushRegistrationDidFinish;
/// Called when the SDK registration for LP Pusher service has been failed with error.
/// Pusher is the service that responsible for Remote Push Notifications routing and delivering from and to APNS.
/// \param error failure error reason
///
- (void)LPMessagingSDKPushRegistrationDidFail:(NSError * _Nonnull)error;
/// Called when an Unauthenticated user expired and can no longer be in used.
/// When this callback is invoked, the previous open conversation will be closed locally.
- (void)LPMessagingSDKUnauthenticatedUserExpired;
@end


SWIFT_CLASS("_TtC14LPMessagingSDK14LPNotification")
@interface LPNotification : NSObject
@property (nonatomic, copy) NSString * _Nonnull text;
@property (nonatomic, strong) LPUser * _Nonnull user;
@property (nonatomic, copy) NSString * _Nonnull accountID;
@property (nonatomic) BOOL isRemote;
@property (nonatomic, readonly, copy) NSString * _Nonnull toString;
- (nonnull instancetype)initWithText:(NSString * _Nonnull)text firstName:(NSString * _Nullable)firstName lastName:(NSString * _Nullable)lastName uid:(NSString * _Nullable)uid accountID:(NSString * _Nonnull)accountID isRemote:(BOOL)isRemote;
- (nonnull instancetype)initWithMessage:(LPMessageEntity * _Nonnull)message isRemote:(BOOL)isRemote;
- (nonnull instancetype)initWithText:(NSString * _Nonnull)text user:(LPUser * _Nonnull)user accountID:(NSString * _Nonnull)accountID isRemote:(BOOL)isRemote OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSCoder;

SWIFT_CLASS("_TtC14LPMessagingSDK19LPRadialProgressBar")
@interface LPRadialProgressBar : UIView
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end



@class UIColor;

SWIFT_CLASS("_TtC14LPMessagingSDK12NSBouncyView")
@interface NSBouncyView : UIView
- (void)setView:(UIView * _Nonnull)view SWIFT_DEPRECATED_OBJC("Swift method 'NSBouncyView.setView(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)setColorWithColor:(UIColor * _Nonnull)color SWIFT_DEPRECATED_OBJC("Swift method 'NSBouncyView.setColor(color:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)toggleVisibilityWithShow:(BOOL)show willStart:(void (^ _Nonnull)(void))willStart didComplete:(void (^ _Nonnull)(void))didComplete didFail:(void (^ _Nonnull)(void))didFail SWIFT_DEPRECATED_OBJC("Swift method 'NSBouncyView.toggleVisibility(show:willStart:didComplete:didFail:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




SWIFT_CLASS("_TtC14LPMessagingSDK22RemoteUserIsTypingView")
@interface RemoteUserIsTypingView : UIView
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (void)awakeFromNib;
@end


SWIFT_CLASS("_TtC14LPMessagingSDK5Toast")
@interface Toast : UIView
@property (nonatomic, copy) NSString * _Nullable name SWIFT_DEPRECATED_OBJC("Swift property 'Toast.name' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@property (nonatomic, copy) void (^ _Nullable didShow)(void) SWIFT_DEPRECATED_OBJC("Swift property 'Toast.didShow' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@property (nonatomic, copy) void (^ _Nullable didDismiss)(void) SWIFT_DEPRECATED_OBJC("Swift property 'Toast.didDismiss' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@property (nonatomic, copy) void (^ _Nullable didTap)(void) SWIFT_DEPRECATED_OBJC("Swift property 'Toast.didTap' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@property (nonatomic) BOOL showAboveStatusBar SWIFT_DEPRECATED_OBJC("Swift property 'Toast.showAboveStatusBar' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)awakeFromNib;
/// Changes text of toast (even on runtime when the toast is showing)
/// \param text text to show
///
- (void)changeTextWithText:(NSString * _Nonnull)text SWIFT_DEPRECATED_OBJC("Swift method 'Toast.changeText(text:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




SWIFT_CLASS("_TtC14LPMessagingSDK7Toaster")
@interface Toaster : UIView
@property (nonatomic, weak) UIViewController * _Nullable containerViewController SWIFT_DEPRECATED_OBJC("Swift property 'Toaster.containerViewController' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@property (nonatomic, readonly, strong) Toast * _Nullable current SWIFT_DEPRECATED_OBJC("Swift property 'Toaster.current' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// Inits the toast object with container view controller
- (nonnull instancetype)initWithContainerViewController:(UIViewController * _Nonnull)containerViewController SWIFT_DEPRECATED_OBJC("Swift initializer 'Toaster.init(containerViewController:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (nonnull instancetype)initWithContainerView:(UIView * _Nonnull)containerView SWIFT_DEPRECATED_OBJC("Swift initializer 'Toaster.init(containerView:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// Receives a toast and puts it at the correct index inside the toasts array
/// \param toast toast object
///
- (void)addWithToast:(Toast * _Nonnull)toast SWIFT_DEPRECATED_OBJC("Swift method 'Toaster.add(toast:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// Dissmisses a specific toast instance
/// If the toast is showing, it animates it out, if not, it just removes it from the list
/// If it doesn’t exist, nothing will happen
/// \param toast toast instance
///
- (void)dismissWithToast:(Toast * _Nonnull)toast SWIFT_DEPRECATED_OBJC("Swift method 'Toaster.dismiss(toast:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// Dismisses all toasts of a specific type
/// \param type A type of toast to dismiss
///
- (void)dismissToastByName:(NSString * _Nonnull)name SWIFT_DEPRECATED_OBJC("Swift method 'Toaster.dismissToast(byName:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// Dissmis all toasts
- (void)dismissAll SWIFT_DEPRECATED_OBJC("Swift method 'Toaster.dismissAll()' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end

@class UITextView;
@class UIGestureRecognizer;

SWIFT_PROTOCOL("_TtP14LPMessagingSDK17UIAdapterDelegate_")
@protocol UIAdapterDelegate
@optional
- (BOOL)sendClickedWithMessage:(NSString * _Nonnull)message inConversation:(LPConversationEntity * _Nonnull)inConversation metadata:(NSArray<NSDictionary<NSString *, id> *> * _Nullable)metadata SWIFT_WARN_UNUSED_RESULT;
- (void)executeActionAtIndex:(UIViewController * _Nonnull)viewController index:(NSInteger)index conversation:(LPConversationEntity * _Nullable)conversation completion:(void (^ _Nonnull)(void))completion;
- (void)textViewDidBeginEditingWithConversation:(LPDialogEntity * _Nullable)dialog;
- (void)textViewDidEndEditingWithConversation:(LPDialogEntity * _Nullable)dialog;
- (BOOL)textView:(UITextView * _Nonnull)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString * _Nonnull)text dialog:(LPDialogEntity * _Nullable)dialog SWIFT_WARN_UNUSED_RESULT;
- (BOOL)shouldSetUIReadOnly:(LPConversationEntity * _Nullable)conversation SWIFT_WARN_UNUSED_RESULT;
- (UIColor * _Nonnull)getTableViewBackgroundColor:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
- (UIImage * _Nonnull)getDefaultRecepientAvatarImage:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
- (UIGestureRecognizer * _Nonnull)getTableViewCustomGestureRecognizer SWIFT_WARN_UNUSED_RESULT;
@end










@interface UIImageView (SWIFT_EXTENSION(LPMessagingSDK)) <UIGestureRecognizerDelegate>
- (BOOL)gestureRecognizer:(UIGestureRecognizer * _Nonnull)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer * _Nonnull)otherGestureRecognizer SWIFT_WARN_UNUSED_RESULT;
@end













#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#else
// Headers for Device
// Generated by Apple Swift version 5.1.3 (swiftlang-1100.0.282.1 clang-1100.0.33.15)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreGraphics;
@import Foundation;
@import LPAMS;
@import LPInfra;
@import ObjectiveC;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="LPMessagingSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif


SWIFT_PROTOCOL("_TtP14LPMessagingSDK39ConversationViewControllerAgentDelegate_")
@protocol ConversationViewControllerAgentDelegate
@optional
- (void)agentDidChangeUserInputText:(NSString * _Nonnull)text;
@end

@protocol LPMessagingAPIDelegate;
@class LPUser;
@protocol LPMessagingSDKNotificationDelegate;
@class LPCampaignInfo;
@protocol ConversationParamProtocol;
@class LPAuthenticationParams;
@class LPBrandEntity;
@class LPConversationEntity;
@class LPDialogEntity;
@class LPMessageEntity;
@class NSError;
@class CSATModel;
@class LPWelcomeMessage;
@class UploadInfo;
@class LPFileEntity;
@class RequestSwiftURL;
@class Ring;
@class LPFormEntity;
@class LPLinkPreviewEntity;
@class LPWebSocket;
@class UIImage;
@class LPConversationHistoryControlParam;
@class LPUserEntity;

SWIFT_CLASS("_TtC14LPMessagingSDK14LPMessagingAPI")
@interface LPMessagingAPI : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Initialize all underlying layers of the SDK.
///
/// returns:
/// Bool if initialization is successful
+ (BOOL)initializeAPI SWIFT_WARN_UNUSED_RESULT;
/// Set LPMessagingAPIDelegate implementor
+ (void)setDelegate:(id <LPMessagingAPIDelegate> _Nonnull)delegate;
/// Remove LPMessagingAPIDelegate implementor
+ (void)removeDelegate:(id <LPMessagingAPIDelegate> _Nonnull)delegate;
/// This method sets user details for the consumer of a brand.
/// The user object is in Type of LPUser which includes all the user details.
/// Additional paramaters:
/// <brandID> is the brand of the related user.
/// If the SDK is not connected, it’ll save the last user for each brand, until connected.
+ (void)setUserProfileWithDetails:(LPUser * _Nonnull)lpuser brandID:(NSString * _Nonnull)brandID;
/// This method registers the host app in the SDK Pusher service in order to be able to receive push notification in messaging.
/// Optional paramaters:
/// <notificationDelegate> is the implementer of LPMessagingSDKNotificationDelegate.
/// <alternateBundleID> is a value for using in order to let the Pusher service to identify the host app with this bundle identifier.
+ (void)registerPushNotificationsWithToken:(NSData * _Nonnull)token notificationDelegate:(id <LPMessagingSDKNotificationDelegate> _Nullable)notificationDelegate alternateBundleID:(NSString * _Nullable)alternateBundleID;
/// This method created ConversationParamProtocol of Brand query type.
+ (id <ConversationParamProtocol> _Nonnull)getConversationBrandQuery:(NSString * _Nonnull)brandID campaignInfo:(LPCampaignInfo * _Nullable)campaignInfo SWIFT_WARN_UNUSED_RESULT;
/// This method created ConversationParamProtocol of Consumer and Skill query type.
+ (id <ConversationParamProtocol> _Nonnull)getConversationConsumerQuery:(NSString * _Nullable)consumerID brandID:(NSString * _Nonnull)brandID agentToken:(NSString * _Nonnull)agentToken SWIFT_WARN_UNUSED_RESULT;
/// This method checks for an active(Open/Created) conversation according to conversation query.
/// Return value:
/// True - there is an active conversation.
/// False - there is no active conversation.
+ (BOOL)checkActiveConversation:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// This method checks if the active conversation of a conversation query marked as Urgent.
/// Return value:
/// True - conversation is marked as Urgent.
/// False - conversation is not marked as Urgent.
+ (BOOL)isUrgent:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// This method marks the active conversation of a conversation query as Urgent.
+ (void)changeUrgentState:(id <ConversationParamProtocol> _Nonnull)conversationQuery isUrgent:(BOOL)isUrgent;
/// This method ends the active conversation if exists.
+ (void)resolveConversationForConversationQuery:(id <ConversationParamProtocol> _Nonnull)conversationQuery;
/// This methods returns the assigned agent of the active or the latest closed conversation, if exists.
+ (LPUser * _Nullable)getAssignedAgent:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// This method determines wether a brandID is Ready.
/// Ready means that the brand is connected and conversation can be proccessed.
+ (BOOL)isBrandReady:(NSString * _Nonnull)brandID SWIFT_WARN_UNUSED_RESULT;
/// This method returns the SDK version.
+ (NSString * _Nullable)getSDKVersion SWIFT_WARN_UNUSED_RESULT;
/// Reset last saved scroll position of the conversation screen
+ (void)resetConversationScreenSavedScrollPosition;
/// Get inActive time in second from the user last touch on screen
///
/// returns:
/// TimeInterval (Double)
+ (NSTimeInterval)getInactiveUserInteractionTimeInterval:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// Appends content to the message text field
/// \param text Text to append
///
+ (void)addContentToMessageWithText:(NSString * _Nonnull)text;
/// This method overrides the state of the AMS state machine for a conversation query
/// \param conversationQuery used to identify the related brand
///
/// \param state the new state to be updated
///
+ (void)updateAMSState:(id <ConversationParamProtocol> _Nonnull)conversationQuery state:(enum AMSState)state;
/// Perform connect to socket for conversationQuery
/// @param:
/// <ul>
///   <li>
///     optional ready completion which will be called after the socket is connected
///   </li>
/// </ul>
+ (void)connectToSocket:(id <ConversationParamProtocol> _Nonnull)conversationQuery readyCompletion:(void (^ _Nullable)(void))readyCompletion;
/// Perform reconnect to socket for conversationQuery:
/// <ul>
///   <li>
///     Remove the websocket handler
///   </li>
///   <li>
///     connect to socket
///     @param:
///   </li>
///   <li>
///     optional ready completion which will be called after the socket is connected
///   </li>
///   <li>
///     optional an LPAuthenticationParams object to determine the properties of an authenticated connection. LPAuthenticationParams supports Code Flow login or Implicit Flow login.
///   </li>
/// </ul>
+ (void)reconnectToSocket:(id <ConversationParamProtocol> _Nonnull)conversationQuery authenticationParams:(LPAuthenticationParams * _Nonnull)authenticationParams readyCompletion:(void (^ _Nullable)(void))readyCompletion;
/// Perform disconnect from socket for conversationQuery.
/// You can choose to disconnect the socket aftet delay of predefined time
/// \param conversationQuery conversationQuery where to socket belongs to
///
/// \param shouldUseDelay determines whether to keep socket open for delay
///
+ (void)disconnectSocket:(id <ConversationParamProtocol> _Nonnull)conversationQuery;
/// Clear history of all closed conversations and their messages from the database.
/// This method is allowed only if there is no active/open conversation.
+ (BOOL)clearHistory:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// Delete all conversations and their messages from the database, which older than X months.
/// The number of months allowed is defined in LPConfig with attribute: deleteClosedConversationOlderThanMonths
+ (void)deleteOldConversations;
/// Create new conversation instance
+ (LPConversationEntity * _Nonnull)createConversation:(LPBrandEntity * _Nonnull)brand SWIFT_WARN_UNUSED_RESULT;
/// Send message from a Message instance related to an owner conversation
+ (void)sendMessageInDialog:(LPDialogEntity * _Nonnull)dialog message:(LPMessageEntity * _Nonnull)message completion:(void (^ _Nonnull)(LPMessageEntity * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Send message from a text string related to an owner conversation
/// This method will create new Message instance in the database.
/// Messages might be masked depending on regex and masking from LPConfig
+ (void)sendMessageInDialog:(LPDialogEntity * _Nonnull)dialog text:(NSString * _Nonnull)text completion:(void (^ _Nonnull)(LPMessageEntity * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Resolve/End a conversation from the user side
+ (void)resolveConversation:(LPConversationEntity * _Nonnull)conversation;
/// Request to change the conversation urgency status to on/off
+ (BOOL)requestUrgentResponse:(LPConversationEntity * _Nonnull)conversation urgent:(BOOL)urgent SWIFT_WARN_UNUSED_RESULT;
/// Retreive new messages from server for an owner converation
+ (void)retrieveNewMessagesForConversation:(LPConversationEntity * _Nonnull)conversation completion:(void (^ _Nullable)(NSArray<LPMessageEntity *> * _Nonnull))completion failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
/// Send CSAT to the server for an owner conversation (submit or skipped)
/// CSAT model is based on: rate of the csat, resolutionConfirmation toggle and wether csat is skipped or not
+ (void)sendCSAT:(LPConversationEntity * _Nonnull)conversation csat:(CSATModel * _Nonnull)csat;
/// Subscribe for exConversation notifications per for brandID
/// Use last updated time from the saved subscription times dictionary
/// Note: if there is an existing previous subscriptionID, unregister it before registering new one.
+ (void)subscribeConversationNotifications:(NSString * _Nonnull)brandID userID:(NSString * _Nonnull)userID socketType:(enum SocketType)socketType completion:(void (^ _Nullable)(NSString * _Nonnull))completion failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
/// Unsubscribe from exConversation notifications per brandID for subscriptionID
+ (void)unsubscribeConversationNotifications:(NSString * _Nonnull)brandID subscriptionID:(NSString * _Nonnull)subscriptionID;
/// Subscribe to routing tasks notification in order to get new rings for Agent
/// \param brandID brandID to subscribe for
///
/// \param agentID agentID to get new rings for
///
/// \param completion completion with subscriptionID
///
/// \param failure failure
///
+ (void)subscribeRoutingTasks:(NSString * _Nonnull)brandID agentID:(NSString * _Nonnull)agentID completion:(void (^ _Nullable)(NSString * _Nonnull))completion failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
/// Determines whether history query messages already fecthced
+ (BOOL)didFetchHistoryMessagingEventNotifications SWIFT_WARN_UNUSED_RESULT;
/// Determines whether history query messages is now being fetched
+ (BOOL)isFetchingHistoryMessages SWIFT_WARN_UNUSED_RESULT;
/// Determines the name of the assigned agent that should be presented in UI areas.
/// If assigned agent exists and has a nickname - return it. Otherwise, return nil.
/// If nil is returned, it should be handled according to UI area
+ (NSString * _Nullable)agentNameUIRepresentation:(LPConversationEntity * _Nullable)conversation SWIFT_WARN_UNUSED_RESULT;
/// Create resolved system message for dialog, according to resolving side
/// Timestamp - when agent resolved we take the timestamp from server, when consumer resolved we take now.
+ (LPMessageEntity * _Nullable)createResolveLocalMessage:(LPDialogEntity * _Nonnull)dialog endTime:(NSDate * _Nonnull)endTime SWIFT_WARN_UNUSED_RESULT;
/// Creates local system message for masked message according to the current masking type:
/// \param conversation conversation that the message will be added to
///
/// \param isRealTimeMasking should the system message text represent real time masking or client side masking
///
///
/// returns:
/// local masked message, nil if failed
+ (LPMessageEntity * _Nullable)createMessageMaskedLocalMessage:(LPConversationEntity * _Nonnull)conversation isRealTimeMasking:(BOOL)isRealTimeMasking SWIFT_WARN_UNUSED_RESULT;
+ (LPMessageEntity * _Nullable)createWelcomeLocalMessage:(LPDialogEntity * _Nonnull)dialog overrideTime:(NSDate * _Nonnull)overrideTime SWIFT_WARN_UNUSED_RESULT SWIFT_AVAILABILITY(ios,deprecated=12.0.0,obsoleted=14.0.0,message="Use createWelcomeLocalMessage(_ dialog: Dialog, welcomeMessage: LPWelcomeMessage,  overrideTime: Date = Date()) -> Message? instead");
+ (LPMessageEntity * _Nullable)createWelcomeLocalMessage:(LPDialogEntity * _Nonnull)dialog welcomeMessage:(LPWelcomeMessage * _Nonnull)welcomeMessage overrideTime:(NSDate * _Nonnull)overrideTime SWIFT_WARN_UNUSED_RESULT;
/// Upload file from upload info object
/// \param uploadInfo Includes all necessary info about required file to upload
///
/// \param conversation conversation that the file will be added to
///
/// \param completion complition handler
///
/// \param failure failure handler
///
+ (void)uploadFileFromInfoWithUploadInfo:(UploadInfo * _Nonnull)uploadInfo dialog:(LPDialogEntity * _Nonnull)dialog completion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Upload file that is saved on disk and send message (mainly for failed messages)
+ (void)uploadFileFromDiskWithMessage:(LPMessageEntity * _Nonnull)message dialog:(LPDialogEntity * _Nonnull)dialog completion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Downloads a file from Swift server and returns an image to show
+ (void)downloadFileWithDialog:(LPDialogEntity * _Nonnull)dialog file:(LPFileEntity * _Nonnull)file completion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Requests the AMS for an upload url for swift server
+ (void)requestUploadURLWithDialog:(LPDialogEntity * _Nonnull)dialog fileSize:(double)fileSize fileExtention:(NSString * _Nonnull)fileExtention completion:(void (^ _Nonnull)(RequestSwiftURL * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Requests the AMS for a download url from swift server
+ (void)requestDownloadURLWithDialog:(LPDialogEntity * _Nonnull)dialog file:(LPFileEntity * _Nonnull)file completion:(void (^ _Nonnull)(id _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Clear all singleton managers with their properties from memory.
/// This method will release any data objects and data structures.
+ (void)clearManagers;
+ (void)acceptRing:(Ring * _Nonnull)ring agentToken:(NSString * _Nonnull)agentToken completion:(void (^ _Nonnull)(LPConversationEntity * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
+ (void)backToQueue:(NSString * _Nonnull)userID conversation:(LPConversationEntity * _Nonnull)conversation completion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
+ (void)subscribeAgentState:(id <ConversationParamProtocol> _Nonnull)conversationQuery agentID:(NSString * _Nonnull)agentID completion:(void (^ _Nullable)(id _Nonnull))completion failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
+ (void)setAgentState:(id <ConversationParamProtocol> _Nonnull)conversationQuery agentID:(NSString * _Nonnull)agentID channels:(NSArray<NSString *> * _Nullable)channels availability:(NSString * _Nonnull)availability description:(NSString * _Nonnull)description completion:(void (^ _Nullable)(id _Nonnull))completion failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
+ (void)agentRequestConversation:(id <ConversationParamProtocol> _Nonnull)conversationQuery context:(NSDictionary<NSString *, NSString *> * _Nonnull)context ttrDefName:(NSString * _Nonnull)ttrDefName channelType:(NSString * _Nonnull)channelType consumerId:(NSString * _Nonnull)consumerId completion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
+ (NSArray<NSString *> * _Nonnull)getAllConsumersID SWIFT_WARN_UNUSED_RESULT;
/// Prepare secure form to be open in a webview
/// This method generates read and write OTK from UMS and build URL to be used for PCI GW
/// \param form form object to get the url for
///
/// \param completion completion block when the form is ready - url and token are valid
///
/// \param failure failure block with error
///
+ (void)prepareSecureFormWithForm:(LPFormEntity * _Nonnull)form completion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Gets link preview messages with a state of “loading”
///
/// returns:
/// Optional array of messages
+ (NSArray<LPMessageEntity *> * _Nullable)getLoadingStructuredContentMessages SWIFT_WARN_UNUSED_RESULT;
/// Gets link preview boards with a state of “loading”
///
/// returns:
/// Optional array of custom boards
+ (NSArray<LPLinkPreviewEntity *> * _Nullable)getLoadingStructuredContentCustomItems SWIFT_WARN_UNUSED_RESULT;
/// Determine if the brand has an active controller/bot in his conversations
/// \param brandID brandID owner of the controller
///
///
/// returns:
/// true if active else false
+ (BOOL)hasActiveController:(NSString * _Nonnull)brandID SWIFT_WARN_UNUSED_RESULT;
/// Get current WebSocket (LPWebSocket) for brand if exists
+ (LPWebSocket * _Nullable)getSocket:(NSString * _Nonnull)brandID SWIFT_WARN_UNUSED_RESULT;
/// Open and reconnect each WebSocket in the web sockets map.
+ (void)openAllSockets;
/// Open and reconnect single WebSocket and assign to web sockets map.
/// This method creates new WebSocket instances based on the previous ones because we can’t reuse WebSocket instances.
+ (void)openSocket:(LPWebSocket * _Nonnull)webSocket;
/// Close all sockets in the web sockets map
/// We DON’T remove the web sockets from the map in order to be able to re-create web socket from a previous one
+ (void)closeAllSockets;
/// Create file from UploadInfo and return when ready if succeeded, invoke error otherwise.
/// Using GeneratePhotoOperation
+ (void)prepareFileWithUploadInfo:(UploadInfo * _Nonnull)uploadInfo fileReadyCompletion:(void (^ _Nonnull)(LPFileEntity * _Nonnull))fileReadyCompletion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Upload File to Swift server and AMS using file operation
+ (void)uploadFileWithFile:(LPFileEntity * _Nonnull)file uploadRelativePath:(NSString * _Nonnull)uploadRelativePath tempURLSig:(NSString * _Nonnull)tempURLSig tempURLExpiry:(NSString * _Nonnull)tempURLExpiry completion:(void (^ _Nonnull)(LPFileEntity * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Get full photo image from disk using file path.
/// If file path is invalid, an error will be invoked.
/// If file does not exist on disk, function will return nil for image.
+ (void)getPhotoFromFileWithFile:(LPFileEntity * _Nonnull)file completion:(void (^ _Nonnull)(UIImage * _Nullable))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Ensure that file has been saved to disk, and return that entity.
/// If file path is invalid, an error will be invoked.
/// If file has does not exist on disk, function will return nil for fileEntity
+ (void)getFileFromFileEntityWithFileEntity:(LPFileEntity * _Nonnull)fileEntity completion:(void (^ _Nonnull)(LPFileEntity * _Nullable))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Get full thumbnail image from disk using file path.
/// If image fails to created or file path is invalid, an error will be invoked.
+ (void)getThumbnailFromFileWithFile:(LPFileEntity * _Nonnull)file completion:(void (^ _Nonnull)(UIImage * _Nullable))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Get thumbnail for the files in file sharing from custom configurations.
/// If custom configurations is nil, provide the thumbnail based on the files UTI
/// \param file local file to get the thumbnail from
///
- (UIImage * _Nonnull)getThumbnailForFileTypeWithFile:(LPFileEntity * _Nonnull)file SWIFT_WARN_UNUSED_RESULT;
/// Returns a base64 string representation of the file’s thumbnail
+ (void)getBase64ThumbnailStringWithFile:(LPFileEntity * _Nonnull)file completion:(SWIFT_NOESCAPE void (^ _Nonnull)(NSString * _Nonnull))completion failure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Returns a base64 string representation of blank thumbnail file
+ (void)getBase64BlankThumbnailStringWithCompletion:(SWIFT_NOESCAPE void (^ _Nonnull)(NSString * _Nonnull))completion failure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Deletes file and thumbnail from disk
+ (void)deleteFileFromDiskWithFile:(LPFileEntity * _Nonnull)file;
/// Deleting the main directory with all files in it from the disk
/// This method is performed in background thread
+ (void)deleteAllFilesFromDiskWithCompletion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// This method delete number of files that exceeded maxNumberOfSavedFilesOnDisk from configuration.
/// The files will be get deleted accoring to FIFO methodology.
/// This method is performed in background thread and only of the photo sharing feature is enabled
+ (void)handleMaxNumberOfSavedFilesOnDisk;
/// Get Brand object for account ID
/// If there is no brand object for the account ID, a new brand will be created in DB
+ (LPBrandEntity * _Nonnull)getOrCreateBrandByAccountID:(NSString * _Nonnull)accountID SWIFT_WARN_UNUSED_RESULT;
/// Clear a single conversation and its assoicated messages and files (also from the disk)
/// Return TRUE if the conversation and its messages was deleted.
/// Return FALSE if the conversation or one if its messages were failed to delete.
+ (BOOL)clearConversationFromDB:(LPConversationEntity * _Nonnull)conversation SWIFT_WARN_UNUSED_RESULT;
/// Get all closed conversations from database
+ (NSArray<LPConversationEntity *> * _Nullable)getAllClosedConversations:(NSDate * _Nullable)olderThanDate SWIFT_WARN_UNUSED_RESULT;
/// Get all conversations from DB sorted by creation date (first object is the latest conversation)
/// If includeQueriedOnly parameter is false, only new conversations or conversations which messages should not be queried, will be returned
+ (NSArray<LPConversationEntity *> * _Nonnull)getConversationsSortedByDate:(id <ConversationParamProtocol> _Nonnull)query conversationHistoryControlParam:(LPConversationHistoryControlParam * _Nullable)conversationHistoryControlParam SWIFT_WARN_UNUSED_RESULT;
/// Attach completion block which is being invoken when the Consumer (My) User is retrieved
+ (void)attachMyUserCompletion:(void (^ _Nonnull)(NSString * _Nonnull))completion;
/// This method fetch user from the database.
/// <ul>
///   <li>
///     Fetch user data from database
///   </li>
///   <li>
///     If user does not exist, a nil will be returned
///   </li>
/// </ul>
+ (LPUserEntity * _Nullable)getUserFromDatabaseWithUserID:(NSString * _Nonnull)userID SWIFT_WARN_UNUSED_RESULT;
/// Fetching the user profile (consumer or agent) from server and update in database received details and current date as lastUpdated
/// Fetch will be performed in the following cases:
/// <ol>
///   <li>
///     User was never fetched
///   </li>
///   <li>
///     User was not fetched in current app run
///   </li>
///   <li>
///     User was not fetched for more than 24Hrs
///   </li>
/// </ol>
+ (void)refreshUserProfileWithBrandID:(NSString * _Nonnull)brandID user:(LPUserEntity * _Nonnull)user;
/// Set token for Pusher service in order to be able to receive remote push notifications
/// Optional - alternateBundleID, set custom bundle ID for Pusher with for the token
+ (void)setPusherTokenWithToken:(NSData * _Nonnull)token alternateBundleID:(NSString * _Nullable)alternateBundleID;
/// Set token for VoIP Pusher service in order to be able to receive remote calls
/// Optional - alternateBundleID, set custom bundle ID for Pusher with for the token
+ (void)setPusherVoipTokenWithToken:(NSData * _Nonnull)token alternateBundleID:(NSString * _Nullable)alternateBundleID;
/// Register pusher with push notification token received from APNS (Apple).
/// Before registering the Pusher, we make sure have the following params:
/// <ul>
///   <li>
///     Consumer UserID
///   </li>
///   <li>
///     Push Token from Apple
///   </li>
///   <li>
///     CSDS Domain for Pusher
///   </li>
///   <li>
///     Account (brand account)
///     When all params availble - peform register
///   </li>
/// </ul>
+ (void)registerPusher:(LPBrandEntity * _Nonnull)brand;
/// Get unread message badge counter
/// There are two options to get this counter:
/// <ol>
///   <li>
///     If the time condition is met we are prefoming a REST request to get it from pusher
///   </li>
///   <li>
///     otherwise, return the cached number we have
///   </li>
/// </ol>
/// note:
/// this method requires the user to accept/allow push notifications (dependancy of pusher)
/// \param conversationQuery conversationQuery: used to identify the related brand
///
/// \param completion called once the operation ends sucessfully
///
/// \param failure called once the operation failed
///
+ (void)getUnreadMessagesCount:(id <ConversationParamProtocol> _Nonnull)conversationQuery completion:(void (^ _Nonnull)(NSInteger))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Get unread message badge counter
/// \param brandID the account number for the brand
///
/// \param completion called once the operation ends sucessfully
///
/// \param failure called once the operation failed
///
+ (void)getUnreadMessagesCountWithBrandID:(NSString * _Nonnull)brandID completion:(void (^ _Nonnull)(NSInteger))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Unregister pusher.
/// Before unregistering the Pusher, we make sure we have the following params:
/// <ul>
///   <li>
///     Consumer UserID
///   </li>
///   <li>
///     CSDS Domain for Pusher
///   </li>
///   <li>
///     Account (brand account)
///     When all params availble - peform unregister
///   </li>
/// </ul>
+ (void)unregisterPusher:(LPBrandEntity * _Nonnull)brand completion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Get CSDS domain for accountID and service name
/// This method get all the CSDS domains and look for the specific domain per service
+ (void)getCSDSDomain:(NSString * _Nonnull)accountID serviceName:(NSString * _Nonnull)serviceName completion:(void (^ _Nonnull)(NSString * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Get All CSDS Service Domains
/// This method uses cache to store and fetch services domains. For every new app session, the CSDS cache will get updated from server
/// Completion blocks will be invoked once there is a stored cache or after the request from the server completed
/// \param accountID accountID to get all services for
///
/// \param completion completion block with the response domains from server
///
/// \param failure failure block with error which will be invoked if server request failed
///
+ (void)getAllCSDSDomains:(NSString * _Nonnull)accountID completion:(void (^ _Nonnull)(NSArray<NSDictionary<NSString *, id> *> * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Set image for URL in images cache
+ (void)setImageByURL:(UIImage * _Nonnull)image url:(NSString * _Nonnull)url;
/// Get image by URL from images cache
+ (UIImage * _Nullable)getImageByURL:(NSString * _Nonnull)url SWIFT_WARN_UNUSED_RESULT;
/// Determine if network is reachable using reachability framework
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL isNetworkReachable;)
+ (BOOL)isNetworkReachable SWIFT_WARN_UNUSED_RESULT;
/// Get open conversation from DB
///
/// returns:
/// an open conversation if exists - if none, returns nil
+ (LPConversationEntity * _Nullable)getOpenConveration SWIFT_WARN_UNUSED_RESULT;
/// Get array of consumer ids that are related to messages that contain a certain string
/// \param text The string that the messages should contain
///
///
/// returns:
/// Array of consumer ids or nil if none found
+ (NSArray<NSString *> * _Nullable)getConsumerIdsRelatedToMessagesThatContains:(NSString * _Nonnull)text SWIFT_WARN_UNUSED_RESULT;
@end


/// We use this protocol as a mirror for LPAMSFacadeDelegate When setting delegate for LPMessagingAPIDelegate we just pass it as LPAMSFacadeDelegate to LPAMSFacade. Note: Before adding new methods this LPMessagingAPIDelegate but not to LPAMSFacadeDelegate, you should Implement LPAMSFacadeDelegate in this class and then call the delegate of LPMessagingAPIDelegate
SWIFT_PROTOCOL("_TtP14LPMessagingSDK22LPMessagingAPIDelegate_")
@protocol LPMessagingAPIDelegate <LPAMSFacadeDelegate>
@end

@protocol LPMessagingSDKdelegate;
@class LPMonitoringInitParams;
@class UIViewController;
@class LPConversationViewParams;
@class UIBarButtonItem;
@class LPLog;

SWIFT_CLASS("_TtC14LPMessagingSDK14LPMessagingSDK")
@interface LPMessagingSDK : NSObject
@property (nonatomic, weak) id <LPMessagingSDKdelegate> _Nullable delegate;
@property (nonatomic, weak) id <LPMessagingSDKNotificationDelegate> _Nullable notificationDelegate;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) LPMessagingSDK * _Nonnull instance;)
+ (LPMessagingSDK * _Nonnull)instance SWIFT_WARN_UNUSED_RESULT;
/// Initialize the SDK and all of its components.
/// Optional paramaters:
/// <brandID> of the host app.
/// This method throws an error/return false with with an error, in case the initialization failed.
- (BOOL)initialize:(NSString * _Nullable)brandID monitoringInitParams:(LPMonitoringInitParams * _Nullable)monitoringInitParams error:(NSError * _Nullable * _Nullable)error;
/// Show conversation view for conversation query.
/// This method starts the conversation and show all the existing messages it exist.
/// Optional paramaters:
/// <authenticationCode> to use an an authenticated users.
/// <containerViewController> the containter which presents the conversation view as a child View Controller.
/// DEPRECATED - Use showConversation(_ conversationViewParams: LPConversationViewParams) instead
- (void)showConversation:(id <ConversationParamProtocol> _Nonnull)conversationQuery authenticationCode:(NSString * _Nullable)authenticationCode containerViewController:(UIViewController * _Nullable)containerViewController SWIFT_AVAILABILITY(ios,deprecated=9.3.5,obsoleted=14.0.0,message="Use showConversation(_ conversationViewParams: LPConversationViewParams) instead");
/// Show Conversation view and starts the conversation and show all the existing messages it exist.
/// \param conversationViewParams an LPConversationViewParams object to determine the properties of the views. Such as Container or Window or if ViewOnly.
///
/// \param authenticationParams an optional LPAuthenticationParams object to determine the properties of an authenticated connection. If using authenticate connection, this paramater must
/// be passed. LPAuthenticationParams supports Code Flow login or Implicit Flow login.
///
- (void)showConversation:(LPConversationViewParams * _Nonnull)conversationViewParams authenticationParams:(LPAuthenticationParams * _Nullable)authenticationParams;
/// Remove conversation view for conversation query from its container or window view.
/// This method ends the conversation’s connection.
- (void)removeConversation:(id <ConversationParamProtocol> _Nonnull)conversationQuery;
/// This method reconnects the conversation’s connection for conversation query.
/// Reconnect open related webSockets and sync the converstion with its latest updates.
/// Additional paramaters:
/// <authenticationCode> to use an an authenticated users.
- (void)reconnect:(id <ConversationParamProtocol> _Nonnull)conversationQuery authenticationCode:(NSString * _Nonnull)authenticationCode SWIFT_AVAILABILITY(ios,deprecated=9.3.5,obsoleted=14.0.0,message="Use reconnect(_ conversationQuery: ConversationParamProtocol, authenticationParams: LPAuthenticationParams) instead");
/// This method reconnects the conversation’s connection for conversation query.
/// Reconnect open related webSockets and sync the converstion with its latest updates.
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     conversationQuery: conversationQuery of ConversationParamProtocol
///   </li>
///   <li>
///     authenticationParams: an LPAuthenticationParams object to determine the properties of an authenticated connection. LPAuthenticationParams supports Code Flow login or Implicit Flow login.
///   </li>
/// </ul>
- (void)reconnect:(id <ConversationParamProtocol> _Nonnull)conversationQuery authenticationParams:(LPAuthenticationParams * _Nonnull)authenticationParams;
/// This method changes the state of the action menu of the conversation for brandID.
- (void)toggleChatActions:(NSString * _Nonnull)accountID sender:(UIBarButtonItem * _Nullable)sender;
/// This method sets user details for the consumer of a brand.
/// The user object is in Type of LPUser which includes all the user details.
/// Additional paramaters:
/// <brandID> is the brand of the related user.
/// If the SDK is not connected, it’ll save the last user for each brand, until connected.
- (void)setUserProfile:(LPUser * _Nonnull)lpuser brandID:(NSString * _Nonnull)brandID;
/// This method created ConversationParamProtocol of Brand query type.
/// ConversationParamProtocol represents a ’filter’ for the conversation screen, determining which of the conversations will be displayed in the following screens.
/// \param brandID brandID to request the conversation query for
///
/// \param campaignInfo an optional campaign info (LPCampaignInfo) to use advanced routing for the consumer. This object based on campaignID and engagementID
///
///
/// returns:
/// a new ConversationParamProtocol by type of BrandQuery
- (id <ConversationParamProtocol> _Nonnull)getConversationBrandQuery:(NSString * _Nonnull)brandID campaignInfo:(LPCampaignInfo * _Nullable)campaignInfo SWIFT_WARN_UNUSED_RESULT;
/// This method created ConversationParamProtocol of Consumer and Skill query type.
/// ConversationParamProtocol represents a ’filter’ for the conversation screen, determining which of the conversations will be displayed in the following screens.
/// \param consumerID consumerID to request the conversation query for
///
/// \param brandID brandID to request the conversation query for
///
/// \param agentToken a unique token for agent aka Agent Bearer
///
///
/// returns:
/// a new ConversationParamProtocol by type of ConsumerQuery
- (id <ConversationParamProtocol> _Nonnull)getConversationConsumerQuery:(NSString * _Nullable)consumerID brandID:(NSString * _Nonnull)brandID agentToken:(NSString * _Nonnull)agentToken SWIFT_WARN_UNUSED_RESULT;
/// This method checks for an active(Open/Created) conversation according to conversation query.
/// Return value:
/// True - there is an active conversation.
/// False - there is no active conversation.
- (BOOL)checkActiveConversation:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// DEPRECATED - This method sets a custom image for the custom button in the conversation navigationBar.
/// Use customButtonImage instead
- (void)setCustomButton:(UIImage * _Nullable)image SWIFT_AVAILABILITY(ios,deprecated=9.3.5,obsoleted=14.0.0,message="configure the image using customButtonImage in LPConfig instead");
/// This method checks if the active conversation of a conversation query marked as Urgent.
/// Return value:
/// True - conversation is marked as Urgent.
/// False - conversation is not marked as Urgent.
- (BOOL)isUrgent:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// This method marks the active conversation of a conversation query as Urgent.
- (void)markAsUrgent:(id <ConversationParamProtocol> _Nonnull)conversationQuery;
/// This method dismisses the active conversation from Urgent to Normal.
- (void)dismissUrgent:(id <ConversationParamProtocol> _Nonnull)conversationQuery;
/// This method ends the active conversation if exists.
- (void)resolveConversation:(id <ConversationParamProtocol> _Nonnull)conversationQuery;
/// This methods returns the assigned agent of the active or the latest closed conversation, if exists.
- (LPUser * _Nullable)getAssignedAgent:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// This method determines wether a brandID is Ready.
/// Ready means that the brand is connected and conversation can be proccessed.
- (BOOL)isBrandReady:(NSString * _Nonnull)brandID SWIFT_WARN_UNUSED_RESULT;
/// This method returns the SDK version.
- (NSString * _Nullable)getSDKVersion SWIFT_WARN_UNUSED_RESULT;
/// Get Inactive time interval in seconds of the user last touch on screen. This interval applies to scroll/messaging/action menus and any other general action on the conversation screen.
/// If the screen is not active or the application is in background this api will return -1.
///
/// returns:
/// Inactive TimeInterval (Double)
- (NSTimeInterval)getInactiveUserInteractionTimeInterval:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// This method deletes all the messages and closed conversation of the related conversation query.
/// This method throws an error if the conversations history failed to cleared.
/// Note: clear history is allowed only if there is no open/active conversation related to the passed conversation query.
- (BOOL)clearHistory:(id <ConversationParamProtocol> _Nonnull)conversationQuery error:(NSError * _Nullable * _Nullable)error;
/// This method subscribes the host app to recieve log events from a specific log level and above.
/// Optionl log levels: TRACE, DEBUG, INFO, WARNING and ERROR.
/// The completion block will pass LPLog object which consists all the information for the log.
- (void)subscribeLogEvents:(enum LogLevel)logLevel logEvent:(void (^ _Nonnull)(LPLog * _Nonnull))logEvent;
/// Prints all localized string’s keys
- (void)printAllLocalizedKeys;
/// Prints the SDK supported languages
- (void)printSupportedLanguages;
/// Get all supported languages as Strings dictionary where:
/// Key - Locale key
/// Value - explicit language name (example: “English”, “Portuguese (Brazil)”, …)
- (NSDictionary<NSString *, NSString *> * _Nonnull)getAllSupportedLanguages SWIFT_WARN_UNUSED_RESULT;
/// Notifies the SDK that a push notification was tapped.
/// This method should be called immediately after the host app has determined that a notification was tapped.
/// For scroll behavior on push notification tapped, see LPConfig.conversationScrollConfiguration
- (void)setPushNotificationTapped;
@end




@interface LPMessagingSDK (SWIFT_EXTENSION(LPMessagingSDK))
- (void)initSocketForBrandID:(NSString * _Nonnull)brandID agentToken:(NSString * _Nonnull)agentToken readyCompletion:(void (^ _Nullable)(void))readyCompletion SWIFT_METHOD_FAMILY(none);
- (id <ConversationViewControllerAgentDelegate> _Nonnull)showAgentConversationWithConversationViewParams:(LPConversationViewParams * _Nonnull)conversationViewParams SWIFT_WARN_UNUSED_RESULT;
@end


@interface LPMessagingSDK (SWIFT_EXTENSION(LPMessagingSDK))
/// This method registers the host app in the SDK Pusher service in order to be able to receive push notification in messaging.
/// note:
/// If passing authentication params, this method will register immediately to Pusher, the registration will be performed when calling showConversation
/// \param token push device token data
///
/// \param notificationDelegate implementer of LPMessagingSDKNotificationDelegate.
///
/// \param alternateBundleID a value for using in order to let the Pusher service to identify the host app with this bundle identifier
///
/// \param authenticationParams an optional authentication param (LPAuthenticationParams) to be used for immediate Pusher registration
///
- (void)registerPushNotificationsWithToken:(NSData * _Nonnull)token notificationDelegate:(id <LPMessagingSDKNotificationDelegate> _Nullable)notificationDelegate alternateBundleID:(NSString * _Nullable)alternateBundleID authenticationParams:(LPAuthenticationParams * _Nullable)authenticationParams;
/// This method registers Voip the host app to SDK Pusher service
/// \param token push device token data
///
/// \param alternateBundleID a value for using in order to let the Pusher service to identify the host app with this bundle identifier
///
- (void)registerVoipPushNotificationsWithToken:(NSData * _Nonnull)token alternateBundleID:(NSString * _Nullable)alternateBundleID;
/// This method unregisters the host app from SDK Pusher service
/// \param brandId brand/account Identifier
///
- (void)unregisterPusherWithBrandId:(NSString * _Nonnull)brandId completion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Set token for Pusher service in order to be able to receive remote push notifications
/// \param token Data
///
/// \param alternateBundleID String? a custom bundle ID for Pusher with for the token
///
+ (void)setPusherTokenWithToken:(NSData * _Nonnull)token alternateBundleID:(NSString * _Nullable)alternateBundleID;
/// Set token for VoIP Pusher service in order to be able to receive remote calls
/// \param token Data
///
/// \param alternateBundleID String? a custom bundle ID for Pusher with for the token
///
+ (void)setPusherVoipTokenWithToken:(NSData * _Nonnull)token alternateBundleID:(NSString * _Nullable)alternateBundleID;
/// Get unread message badge counter
/// There are two options to get this counter:
/// <ol>
///   <li>
///     If the time condition is met we are prefoming a REST request to get it from pusher
///   </li>
///   <li>
///     otherwise, return the cached number we have
///   </li>
/// </ol>
/// note:
/// this method requires the user to accept/allow push notifications (dependancy of pusher)
/// \param conversationQuery conversationQuery: used to identify the related brand
///
/// \param completion called once the operation ends sucessfully
///
/// \param failure called once the operation failed
///
+ (void)getUnreadMessagesCount:(id <ConversationParamProtocol> _Nonnull)conversationQuery completion:(void (^ _Nonnull)(NSInteger))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Get unread message badge counter
/// \param brandID the account number for the brand
///
/// \param completion called once the operation ends sucessfully
///
/// \param failure called once the operation failed
///
+ (void)getUnreadMessagesCountWithBrandID:(NSString * _Nonnull)brandID completion:(void (^ _Nonnull)(NSInteger))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// This method passes a user info of a remote push notification to be handled by the SDK.
/// <ul>
///   <li>
///     Paramaters:
///     <ul>
///       <li>
///         userInfo: Dictionary
///       </li>
///     </ul>
///   </li>
/// </ul>
- (void)handlePush:(NSDictionary * _Nonnull)userInfo;
@end


@interface LPMessagingSDK (SWIFT_EXTENSION(LPMessagingSDK))
/// This method is a destructive method that is typically used stop and clear all the metadata of the SDK.
/// This method conducts the following:
/// Clears all SDK non-persistent data.
/// Stops all connections.
/// Remove Conversation View Controller
- (void)destruct;
/// This method is a destructive method that is typically used to clean a user’s data before a second user logs into the same device or just to logs the current user out.
/// This method conducts the following:
/// Unregisters from the push notification service.
/// Clears all SDK persistent data.
/// Cleans running operations (see <a href="consumer-experience-ios-sdk-destruct.html">destruct</a>{:target=”<em>blank”}).
/// Invocation of destruct() method
/// DEPRECATED - Use logout(completion: @escaping ()->(), failure: @escaping (</em> error: Error)->()) instead
- (void)logout SWIFT_AVAILABILITY(ios,deprecated=9.3.5,obsoleted=14.0.0,message="Use logout(completion: @escaping ()->(), failure: @escaping (_ error: Error)->()) instead");
/// This method is a destructive method that is typically used to clean a user’s data before a second user logs into the same device or just to logs the current user out.
/// This method conducts the following:
/// Unregisters from the push notification service.
/// Clears all SDK persistent data.
/// Cleans running operations (see <a href="consumer-experience-ios-sdk-destruct.html">destruct</a>{:target=”_blank”}).
/// Invocation of destruct() method
/// note:
/// this method should be called before any persistent clean up tasks are performed on host app
/// \param completion A completion block for successfully logout. Completion block will be invoked only if all logout steps succeeded.
///
/// \param failure A failure block with a specified error for logout failure. Failure block will be invoked if at least one of the logout steps has failed.
///
- (void)logoutWithCompletion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
@end

@class LPNotification;
@class UIView;

SWIFT_PROTOCOL("_TtP14LPMessagingSDK34LPMessagingSDKNotificationDelegate_")
@protocol LPMessagingSDKNotificationDelegate
@optional
- (void)LPMessagingSDKNotificationWithDidReceivePushNotification:(LPNotification * _Nonnull)notification;
- (BOOL)LPMessagingSDKNotificationWithShouldShowPushNotification:(LPNotification * _Nonnull)notification SWIFT_WARN_UNUSED_RESULT;
- (UIView * _Nonnull)LPMessagingSDKNotificationWithCustomLocalPushNotificationView:(LPNotification * _Nonnull)notification SWIFT_WARN_UNUSED_RESULT;
- (void)LPMessagingSDKNotificationWithNotificationTapped:(LPNotification * _Nonnull)notification;
@end


SWIFT_PROTOCOL("_TtP14LPMessagingSDK22LPMessagingSDKdelegate_")
@protocol LPMessagingSDKdelegate
@optional
- (void)LPMessagingSDKCustomButtonTapped;
- (void)LPMessagingSDKAgentDetails:(LPUser * _Nullable)agent;
- (void)LPMessagingSDKAgentAvatarTapped:(LPUser * _Nullable)agent;
- (void)LPMessagingSDKActionsMenuToggled:(BOOL)toggled;
- (void)LPMessagingSDKHasConnectionError:(NSString * _Nullable)error;
- (void)LPMessagingSDKCSATScoreSubmissionDidFinish:(NSString * _Nonnull)brandID rating:(NSInteger)rating;
- (UIView * _Nonnull)LPMessagingSDKCSATCustomTitleView:(NSString * _Nonnull)brandID SWIFT_WARN_UNUSED_RESULT;
- (void)LPMessagingSDKConversationCSATSkipped:(NSString * _Nullable)conversationID;
- (void)LPMessagingSDKUserDeniedPermission:(enum LPPermissionTypes)permissionType;
@required
- (void)LPMessagingSDKObseleteVersion:(NSError * _Nonnull)error;
- (void)LPMessagingSDKAuthenticationFailed:(NSError * _Nonnull)error;
- (void)LPMessagingSDKTokenExpired:(NSString * _Nonnull)brandID;
- (void)LPMessagingSDKError:(NSError * _Nonnull)error;
@optional
- (void)LPMessagingSDKConnectionRetriesFailed:(NSError * _Nonnull)error;
- (void)LPMessagingSDKAgentIsTypingStateChanged:(BOOL)isTyping;
- (void)LPMessagingSDKConversationStarted:(NSString * _Nullable)conversationID;
- (void)LPMessagingSDKConversationEnded:(NSString * _Nullable)conversationID SWIFT_AVAILABILITY(ios,deprecated=9.3.5,obsoleted=14.0.0,message="use LPMessagingSDKConversationEnded(_:closeReason) instead");
- (void)LPMessagingSDKConversationEnded:(NSString * _Nullable)conversationID closeReason:(enum LPConversationCloseReason)closeReason;
- (void)LPMessagingSDKConversationCSATDismissedOnSubmittion:(NSString * _Nullable)conversationID;
- (void)LPMessagingSDKConversationCSATDidLoad:(NSString * _Nullable)conversationID;
- (void)LPMessagingSDKConnectionStateChanged:(BOOL)isReady brandID:(NSString * _Nonnull)brandID;
- (void)LPMessagingSDKOffHoursStateChanged:(BOOL)isOffHours brandID:(NSString * _Nonnull)brandID;
- (void)LPMessagingSDKConversationViewControllerDidDismiss;
/// Called when the Cert pinning mechanism failed. The server trust was successfully evaluated but did not contain any of the configured public keys pins. or The server trust’s evaluation failed: the server’s certificate chain is not trusted.
/// \param error failure error reason
///
- (void)LPMessagingSDKCertPinningFailed:(NSError * _Nonnull)error;
/// Called the SDK registration for  LP Pusher service has been succeeded.
/// Pusher is the service that responsible for Remote Push Notifications routing and delivering from and to APNS.
- (void)LPMessagingSDKPushRegistrationDidFinish;
/// Called when the SDK registration for LP Pusher service has been failed with error.
/// Pusher is the service that responsible for Remote Push Notifications routing and delivering from and to APNS.
/// \param error failure error reason
///
- (void)LPMessagingSDKPushRegistrationDidFail:(NSError * _Nonnull)error;
/// Called when an Unauthenticated user expired and can no longer be in used.
/// When this callback is invoked, the previous open conversation will be closed locally.
- (void)LPMessagingSDKUnauthenticatedUserExpired;
@end


SWIFT_CLASS("_TtC14LPMessagingSDK14LPNotification")
@interface LPNotification : NSObject
@property (nonatomic, copy) NSString * _Nonnull text;
@property (nonatomic, strong) LPUser * _Nonnull user;
@property (nonatomic, copy) NSString * _Nonnull accountID;
@property (nonatomic) BOOL isRemote;
@property (nonatomic, readonly, copy) NSString * _Nonnull toString;
- (nonnull instancetype)initWithText:(NSString * _Nonnull)text firstName:(NSString * _Nullable)firstName lastName:(NSString * _Nullable)lastName uid:(NSString * _Nullable)uid accountID:(NSString * _Nonnull)accountID isRemote:(BOOL)isRemote;
- (nonnull instancetype)initWithMessage:(LPMessageEntity * _Nonnull)message isRemote:(BOOL)isRemote;
- (nonnull instancetype)initWithText:(NSString * _Nonnull)text user:(LPUser * _Nonnull)user accountID:(NSString * _Nonnull)accountID isRemote:(BOOL)isRemote OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSCoder;

SWIFT_CLASS("_TtC14LPMessagingSDK19LPRadialProgressBar")
@interface LPRadialProgressBar : UIView
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end



@class UIColor;

SWIFT_CLASS("_TtC14LPMessagingSDK12NSBouncyView")
@interface NSBouncyView : UIView
- (void)setView:(UIView * _Nonnull)view SWIFT_DEPRECATED_OBJC("Swift method 'NSBouncyView.setView(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)setColorWithColor:(UIColor * _Nonnull)color SWIFT_DEPRECATED_OBJC("Swift method 'NSBouncyView.setColor(color:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)toggleVisibilityWithShow:(BOOL)show willStart:(void (^ _Nonnull)(void))willStart didComplete:(void (^ _Nonnull)(void))didComplete didFail:(void (^ _Nonnull)(void))didFail SWIFT_DEPRECATED_OBJC("Swift method 'NSBouncyView.toggleVisibility(show:willStart:didComplete:didFail:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




SWIFT_CLASS("_TtC14LPMessagingSDK22RemoteUserIsTypingView")
@interface RemoteUserIsTypingView : UIView
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (void)awakeFromNib;
@end


SWIFT_CLASS("_TtC14LPMessagingSDK5Toast")
@interface Toast : UIView
@property (nonatomic, copy) NSString * _Nullable name SWIFT_DEPRECATED_OBJC("Swift property 'Toast.name' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@property (nonatomic, copy) void (^ _Nullable didShow)(void) SWIFT_DEPRECATED_OBJC("Swift property 'Toast.didShow' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@property (nonatomic, copy) void (^ _Nullable didDismiss)(void) SWIFT_DEPRECATED_OBJC("Swift property 'Toast.didDismiss' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@property (nonatomic, copy) void (^ _Nullable didTap)(void) SWIFT_DEPRECATED_OBJC("Swift property 'Toast.didTap' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@property (nonatomic) BOOL showAboveStatusBar SWIFT_DEPRECATED_OBJC("Swift property 'Toast.showAboveStatusBar' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)awakeFromNib;
/// Changes text of toast (even on runtime when the toast is showing)
/// \param text text to show
///
- (void)changeTextWithText:(NSString * _Nonnull)text SWIFT_DEPRECATED_OBJC("Swift method 'Toast.changeText(text:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




SWIFT_CLASS("_TtC14LPMessagingSDK7Toaster")
@interface Toaster : UIView
@property (nonatomic, weak) UIViewController * _Nullable containerViewController SWIFT_DEPRECATED_OBJC("Swift property 'Toaster.containerViewController' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@property (nonatomic, readonly, strong) Toast * _Nullable current SWIFT_DEPRECATED_OBJC("Swift property 'Toaster.current' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// Inits the toast object with container view controller
- (nonnull instancetype)initWithContainerViewController:(UIViewController * _Nonnull)containerViewController SWIFT_DEPRECATED_OBJC("Swift initializer 'Toaster.init(containerViewController:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (nonnull instancetype)initWithContainerView:(UIView * _Nonnull)containerView SWIFT_DEPRECATED_OBJC("Swift initializer 'Toaster.init(containerView:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// Receives a toast and puts it at the correct index inside the toasts array
/// \param toast toast object
///
- (void)addWithToast:(Toast * _Nonnull)toast SWIFT_DEPRECATED_OBJC("Swift method 'Toaster.add(toast:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// Dissmisses a specific toast instance
/// If the toast is showing, it animates it out, if not, it just removes it from the list
/// If it doesn’t exist, nothing will happen
/// \param toast toast instance
///
- (void)dismissWithToast:(Toast * _Nonnull)toast SWIFT_DEPRECATED_OBJC("Swift method 'Toaster.dismiss(toast:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// Dismisses all toasts of a specific type
/// \param type A type of toast to dismiss
///
- (void)dismissToastByName:(NSString * _Nonnull)name SWIFT_DEPRECATED_OBJC("Swift method 'Toaster.dismissToast(byName:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// Dissmis all toasts
- (void)dismissAll SWIFT_DEPRECATED_OBJC("Swift method 'Toaster.dismissAll()' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end

@class UITextView;
@class UIGestureRecognizer;

SWIFT_PROTOCOL("_TtP14LPMessagingSDK17UIAdapterDelegate_")
@protocol UIAdapterDelegate
@optional
- (BOOL)sendClickedWithMessage:(NSString * _Nonnull)message inConversation:(LPConversationEntity * _Nonnull)inConversation metadata:(NSArray<NSDictionary<NSString *, id> *> * _Nullable)metadata SWIFT_WARN_UNUSED_RESULT;
- (void)executeActionAtIndex:(UIViewController * _Nonnull)viewController index:(NSInteger)index conversation:(LPConversationEntity * _Nullable)conversation completion:(void (^ _Nonnull)(void))completion;
- (void)textViewDidBeginEditingWithConversation:(LPDialogEntity * _Nullable)dialog;
- (void)textViewDidEndEditingWithConversation:(LPDialogEntity * _Nullable)dialog;
- (BOOL)textView:(UITextView * _Nonnull)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString * _Nonnull)text dialog:(LPDialogEntity * _Nullable)dialog SWIFT_WARN_UNUSED_RESULT;
- (BOOL)shouldSetUIReadOnly:(LPConversationEntity * _Nullable)conversation SWIFT_WARN_UNUSED_RESULT;
- (UIColor * _Nonnull)getTableViewBackgroundColor:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
- (UIImage * _Nonnull)getDefaultRecepientAvatarImage:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
- (UIGestureRecognizer * _Nonnull)getTableViewCustomGestureRecognizer SWIFT_WARN_UNUSED_RESULT;
@end










@interface UIImageView (SWIFT_EXTENSION(LPMessagingSDK)) <UIGestureRecognizerDelegate>
- (BOOL)gestureRecognizer:(UIGestureRecognizer * _Nonnull)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer * _Nonnull)otherGestureRecognizer SWIFT_WARN_UNUSED_RESULT;
@end













#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif
