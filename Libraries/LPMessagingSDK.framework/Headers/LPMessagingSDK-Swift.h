// Generated by Apple Swift version 3.1 (swiftlang-802.0.48 clang-802.0.38)
#pragma clang diagnostic push

#if defined(__has_include) && __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if defined(__has_include) && __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if defined(__has_attribute) && __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if defined(__has_attribute) && __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if defined(__has_attribute) && __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if defined(__has_attribute) && __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if defined(__has_attribute) && __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_EXTRA _name : _type
# if defined(__has_feature) && __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) SWIFT_ENUM(_type, _name)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if defined(__has_feature) && __has_feature(modules)
@import ObjectiveC;
@import Foundation;
@import LPInfra;
@import LPAMS;
@import UIKit;
@import CoreGraphics;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
@protocol UIAdapterDelegate;

SWIFT_PROTOCOL("_TtP14LPMessagingSDK39ConversationViewControllerAgentDelegate_")
@protocol ConversationViewControllerAgentDelegate
@optional
- (void)agentDidChangeUserInputText:(NSString * _Nonnull)text;
- (void)setUIAdapterDelegate:(id <UIAdapterDelegate> _Nonnull)delegate;
@end

@protocol LPMessagingAPIDelegate;
@class LPUser;
@protocol LPMessagingSDKNotificationDelegate;
@protocol ConversationParamProtocol;
@class LPBrandEntity;
@class LPConversationEntity;
@class LPMessageEntity;
@class NSError;
@class CSATModel;
@class LPFileEntity;
@class UIImage;
@class Ring;
@class LPWebSocket;
@class LPUserEntity;
@class LPCustomItemEntity;

/// An public API for all messaging capabilities
SWIFT_CLASS("_TtC14LPMessagingSDK14LPMessagingAPI")
@interface LPMessagingAPI : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
/// Initialize all underlying layers of the SDK.
///
/// returns:
/// Bool if initialization is successful
+ (BOOL)initializeAPI SWIFT_WARN_UNUSED_RESULT;
/// Set LPMessagingAPIDelegate implementor
+ (void)setDelegateWithDelegate:(id <LPMessagingAPIDelegate> _Nonnull)delegate;
/// Remove LPMessagingAPIDelegate implementor
+ (void)removeDelegate;
/// This method sets user details for the consumer of a brand.
/// The user object is in Type of LPUser which includes all the user details.
/// Additional paramaters:
/// <brandID> is the brand of the related user.
/// If the SDK is not connected, it’ll save the last user for each brand, until connected.
+ (void)setUserProfileWithDetails:(LPUser * _Nonnull)lpuser brandID:(NSString * _Nonnull)brandID;
/// This method registers the host app in the SDK Pusher service in order to be able to receive push notification in messaging.
/// Optional paramaters:
/// <notificationDelegate> is the implementer of LPMessagingSDKNotificationDelegate.
/// <alternateBundleID> is a value for using in order to let the Pusher service to identify the host app with this bundle identifier.
+ (void)registerPushNotificationsWithToken:(NSData * _Nonnull)token notificationDelegate:(id <LPMessagingSDKNotificationDelegate> _Nullable)notificationDelegate alternateBundleID:(NSString * _Nullable)alternateBundleID;
/// This method created ConversationParamProtocol of Brand query type.
+ (id <ConversationParamProtocol> _Nonnull)getConversationBrandQuery:(NSString * _Nonnull)brandID SWIFT_WARN_UNUSED_RESULT;
/// This method created ConversationParamProtocol of Brand and Skill query type.
+ (id <ConversationParamProtocol> _Nonnull)getConversationBrandAndSkillQuery:(NSString * _Nonnull)brandID skillID:(NSString * _Nonnull)skillID SWIFT_WARN_UNUSED_RESULT;
/// This method created ConversationParamProtocol of Consumer and Skill query type.
+ (id <ConversationParamProtocol> _Nonnull)getConversationConsumerQuery:(NSString * _Nullable)consumerID brandID:(NSString * _Nonnull)brandID agentToken:(NSString * _Nonnull)agentToken SWIFT_WARN_UNUSED_RESULT;
/// This method checks for an active(Open/Created) conversation according to conversation query.
/// Return value:
/// True - there is an active conversation.
/// False - there is no active conversation.
+ (BOOL)checkActiveConversation:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// This method checks if the active conversation of a conversation query marked as Urgent.
/// Return value:
/// True - conversation is marked as Urgent.
/// False - conversation is not marked as Urgent.
+ (BOOL)isUrgent:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// This method marks the active conversation of a conversation query as Urgent.
+ (void)changeUrgentState:(id <ConversationParamProtocol> _Nonnull)conversationQuery isUrgent:(BOOL)isUrgent;
/// This method ends the active conversation if exists.
+ (void)resolveConversationForConversationQuery:(id <ConversationParamProtocol> _Nonnull)conversationQuery;
/// This methods returns the assigned agent of the active or the latest closed conversation, if exists.
+ (LPUser * _Nullable)getAssignedAgent:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// This method determines wether a brandID is Ready.
/// Ready means that the brand is connected and conversation can be proccessed.
+ (BOOL)isBrandReady:(NSString * _Nonnull)brandID SWIFT_WARN_UNUSED_RESULT;
/// This method returns the SDK version.
+ (NSString * _Nullable)getSDKVersion SWIFT_WARN_UNUSED_RESULT;
/// Perform connect to socket for conversationQuery
/// @param:
/// <ul>
///   <li>
///     optional ready completion which will be called after the socket is connected
///   </li>
/// </ul>
+ (void)connectToSocket:(id <ConversationParamProtocol> _Nonnull)conversationQuery readyCompletion:(void (^ _Nullable)(void))readyCompletion;
/// Perform reconnect to socket for conversationQuery:
/// <ul>
///   <li>
///     Remove the websocket handler
///   </li>
///   <li>
///     connect to socket
///     @param:
///   </li>
///   <li>
///     optional ready completion which will be called after the socket is connected
///   </li>
///   <li>
///     optional authenticationCode to use an an authenticated users.
///   </li>
/// </ul>
+ (void)reconnectToSocket:(id <ConversationParamProtocol> _Nonnull)conversationQuery authenticationCode:(NSString * _Nullable)authenticationCode readyCompletion:(void (^ _Nullable)(void))readyCompletion;
/// Perform disconnect from socket for conversationQuery
+ (void)disconnectSocket:(id <ConversationParamProtocol> _Nonnull)conversationQuery;
/// Clear history of all closed conversations and their messages from the database.
/// This method is allowed only if there is no active/open conversation.
+ (BOOL)clearHistory:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// Delete all conversations and their messages from the database, which older than X months.
/// The number of months allowed is defined in LPConfig with attribute: deleteClosedConversationOlderThanMonths
+ (void)deleteOldConversations;
/// Create new conversation instance
+ (LPConversationEntity * _Nonnull)createConversation:(LPBrandEntity * _Nonnull)brand SWIFT_WARN_UNUSED_RESULT;
/// Send message from a Message instance related to an owner conversation
+ (void)sendMessageInConversation:(LPConversationEntity * _Nonnull)conversation message:(LPMessageEntity * _Nonnull)message completion:(void (^ _Nonnull)(LPMessageEntity * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Send message from a text string related to an owner conversation
/// This method will create new Message instance in the database.
/// Messages might be masked depending on regex and masking from LPConfig
+ (void)sendMessageInConversation:(LPConversationEntity * _Nonnull)conversation text:(NSString * _Nonnull)text completion:(void (^ _Nonnull)(LPMessageEntity * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Resolve/End a conversation from the user side
+ (void)resolveConversation:(LPConversationEntity * _Nonnull)conversation;
/// Request to change the conversation urgency status to on/off
+ (BOOL)requestUrgentResponse:(LPConversationEntity * _Nonnull)conversation urgent:(BOOL)urgent SWIFT_WARN_UNUSED_RESULT;
/// Retreive new messages from server for an owner converation
+ (void)retrieveNewMessagesForConversation:(LPConversationEntity * _Nonnull)conversation completion:(void (^ _Nullable)(NSArray<LPMessageEntity *> * _Nonnull))completion failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
/// Send CSAT to the server for an owner conversation (submit or skipped)
/// CSAT model is based on: rate of the csat, resolutionConfirmation toggle and wether csat is skipped or not
+ (void)sendCSAT:(LPConversationEntity * _Nonnull)conversation csat:(CSATModel * _Nonnull)csat;
/// Subscribe for exConversation notifications per for brandID
/// Use last updated time from the saved subscription times dictionary
/// Note: if there is an existing previous subscriptionID, unregister it before registering new one.
+ (void)subscribeConversationNotifications:(NSString * _Nonnull)brandID userID:(NSString * _Nonnull)userID socketType:(enum SocketType)socketType completion:(void (^ _Nullable)(NSString * _Nonnull))completion failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
/// Unsubscribe from exConversation notifications per brandID for subscriptionID
+ (void)unsubscribeConversationNotifications:(NSString * _Nonnull)brandID subscriptionID:(NSString * _Nonnull)subscriptionID;
/// Determines whether history query messages already fecthced
+ (BOOL)didFetchHistoryQueryMessages SWIFT_WARN_UNUSED_RESULT;
/// Determines whether history query messages is now being fetched
+ (BOOL)isFetchingHistoryQueryMessages SWIFT_WARN_UNUSED_RESULT;
/// Determines the name of the assigned agent that should be presented in UI areas.
/// If assigned agent exists and has a nickname - return it. Otherwise, return nil.
/// If nil is returned, it should be handled according to UI area
+ (NSString * _Nullable)agentNameUIRepresentation:(LPConversationEntity * _Nullable)conversation SWIFT_WARN_UNUSED_RESULT;
/// Create resolved system message for conversation, according to resolving side
/// Timestamp - when agent resolved we take the timestamp from server, when consumer resolved we take now.
+ (LPMessageEntity * _Nullable)createResolveLocalMessage:(LPConversationEntity * _Nonnull)conversation endTime:(NSDate * _Nonnull)endTime SWIFT_WARN_UNUSED_RESULT;
/// Creates local system message for masked message according to the current masking type:
/// \param conversation conversation that the message will be added to
///
/// \param isRealTimeMasking should the system message text represent real time masking or client side masking
///
///
/// returns:
/// local masked message, nil if failed
+ (LPMessageEntity * _Nullable)createMessageMaskedLocalMessage:(LPConversationEntity * _Nonnull)conversation isRealTimeMasking:(BOOL)isRealTimeMasking SWIFT_WARN_UNUSED_RESULT;
/// Create welcome local system message for conversation
+ (LPMessageEntity * _Nullable)createWelcomeLocalMessage:(LPConversationEntity * _Nonnull)conversation SWIFT_WARN_UNUSED_RESULT;
/// Upload and send messge with file from gallery or camera based on image info which retrieved in UIImagePickerDelegate
+ (void)uploadFileFromImageInfoWithImageInfo:(NSDictionary<NSString *, id> * _Nonnull)imageInfo caption:(NSString * _Nonnull)caption conversation:(LPConversationEntity * _Null_unspecified)conversation completion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Upload file that is saved on disk and send message (mainly for failed messages)
+ (void)uploadFileFromDiskWithMessage:(LPMessageEntity * _Nonnull)message conversation:(LPConversationEntity * _Nonnull)conversation completion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Downloads a file from Swift server and returns an image to show
+ (void)downloadFileWithConversation:(LPConversationEntity * _Nonnull)conversation file:(LPFileEntity * _Nonnull)file completion:(void (^ _Nonnull)(UIImage * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Clear all singleton managers with their properties from memory.
/// This method will release any data objects and data structures.
+ (void)clearManagers;
+ (void)takeConversation:(Ring * _Nonnull)ring agentToken:(NSString * _Nonnull)agentToken completion:(void (^ _Nonnull)(LPConversationEntity * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
+ (void)backToQueue:(NSString * _Nonnull)userID conversation:(LPConversationEntity * _Nonnull)conversation;
+ (void)subscribeAgentState:(NSString * _Nonnull)agentID conversation:(LPConversationEntity * _Nonnull)conversation;
+ (void)setAgentState:(NSString * _Nonnull)agentUserId channels:(NSArray<NSString *> * _Nonnull)channels availability:(NSString * _Nonnull)availability description:(NSString * _Nonnull)description conversation:(LPConversationEntity * _Nonnull)conversation;
+ (void)agentRequestConversation:(NSDictionary<NSString *, NSString *> * _Nonnull)context ttrDefName:(NSString * _Nonnull)ttrDefName channelType:(NSString * _Nonnull)channelType consumerId:(NSString * _Nonnull)consumerId conversation:(LPConversationEntity * _Nonnull)conversation;
+ (NSArray<NSString *> * _Nonnull)getAllConsumersID SWIFT_WARN_UNUSED_RESULT;
/// Get all the conversations fetched from the DB by userId query
///
/// returns:
/// Dictionary of ConversationId:Conversation
+ (NSDictionary<NSString *, NSArray<LPConversationEntity *> *> * _Nonnull)getConversationsByConsumers SWIFT_WARN_UNUSED_RESULT;
/// Get current WebSocket (LPWebSocket) for brand if exists
+ (LPWebSocket * _Nullable)getSocket:(NSString * _Nonnull)brandID SWIFT_WARN_UNUSED_RESULT;
/// Open and reconnect each WebSocket in the web sockets map.
+ (void)openAllSockets;
/// Open and reconnect single WebSocket and assign to web sockets map.
/// This method creates new WebSocket instances based on the previous ones because we can’t reuse WebSocket instances.
+ (void)openSocket:(LPWebSocket * _Nullable)webSocket;
/// Close all sockets in the web sockets map
/// We DON’T remove the web sockets from the map in order to be able to re-create web socket from a previous one
+ (void)closeAllSockets;
/// Upload File to Swift server and AMS using file operation
+ (void)uploadFileWithFile:(LPFileEntity * _Nonnull)file uploadRelativePath:(NSString * _Nonnull)uploadRelativePath tempURLSig:(NSString * _Nonnull)tempURLSig tempURLExpiry:(NSString * _Nonnull)tempURLExpiry completion:(void (^ _Nonnull)(LPFileEntity * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Download file/photo from swift server
+ (void)downloadFileWithFile:(LPFileEntity * _Nonnull)file relativePath:(NSString * _Nonnull)relativePath tempURLSig:(NSString * _Nonnull)tempURLSig tempURLExpiry:(NSString * _Nonnull)tempURLExpiry completion:(void (^ _Nonnull)(LPFileEntity * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Get full photo image from disk using file path.
/// If file path is invalid, an error will be invoked.
/// If file does not exist, function will return nil
+ (void)getPhotoFromFileWithFile:(LPFileEntity * _Nonnull)file completion:(SWIFT_NOESCAPE void (^ _Nonnull)(UIImage * _Nullable))completion failure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Get full thumbnail image from disk using file path.
/// If image fails to created or file path is invalid, an error will be invoked.
+ (UIImage * _Nullable)getThumbnailFromFileWithFile:(LPFileEntity * _Nonnull)file SWIFT_WARN_UNUSED_RESULT;
/// Returns a base64 string representation of the file’s thumbnail
+ (void)getBase64ThumbnailStringWithFile:(LPFileEntity * _Nonnull)file completion:(SWIFT_NOESCAPE void (^ _Nonnull)(NSString * _Nonnull))completion failure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
/// Deletes file and thumbnail from disk
+ (void)deleteFileFromDiskWithFile:(LPFileEntity * _Nonnull)file;
/// Deleting the main directory with all files in it from the disk
/// This method is performed in background thread
+ (void)deleteAllFilesFromDisk;
/// This method delete number of files that exceeded maxNumberOfSavedFilesOnDisk from configuration.
/// The files will be get deleted accoring to FIFO methodology.
/// This method is performed in background thread and only of the photo sharing feature is enabled
+ (void)handleMaxNumberOfSavedFilesOnDisk;
/// Get Brand object for account ID
/// If there is no brand object for the account ID, a new brand will be created in DB
+ (LPBrandEntity * _Nonnull)getOrCreateBrandByAccountID:(NSString * _Nonnull)accountID SWIFT_WARN_UNUSED_RESULT;
/// Clear a single conversation and its assoicated messages and files (also from the disk)
/// Return TRUE if the conversation and its messages was deleted.
/// Return FALSE if the conversation or one if its messages were failed to delete.
+ (BOOL)clearConversationFromDB:(LPConversationEntity * _Nonnull)conversation SWIFT_WARN_UNUSED_RESULT;
/// Get all closed conversations from database
+ (NSArray<LPConversationEntity *> * _Nullable)getAllClosedConversations:(NSDate * _Nullable)olderThanDate SWIFT_WARN_UNUSED_RESULT;
/// Get all conversations from DB sorted by creation date (first object is the latest conversation)
/// If includeQueriedOnly parameter is false, only new conversations or conversations which messages should not be queried, will be returned
+ (NSArray<LPConversationEntity *> * _Nonnull)getConversationsSortedByDate:(id <ConversationParamProtocol> _Nonnull)query includeQueriedOnly:(BOOL)includeQueriedOnly SWIFT_WARN_UNUSED_RESULT;
/// This method fetch user profile from the server.
/// <ul>
///   <li>
///     Fetch user data from server
///   </li>
///   <li>
///     Save to DB
///   </li>
///   <li>
///     Return User to completion block
///   </li>
/// </ul>
+ (void)fetchUser:(NSString * _Nonnull)brandID userID:(NSString * _Nonnull)userID isMe:(BOOL)isMe completion:(void (^ _Nullable)(LPUserEntity * _Nonnull))completion failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
/// Attach completion block which is being invoken when the Consumer (My) User is retrieved
+ (void)attachMyUserCompletion:(void (^ _Nonnull)(NSString * _Nonnull))completion;
/// This method fetch user from the database.
/// <ul>
///   <li>
///     Fetch user data from database
///   </li>
///   <li>
///     If user does not exist, a nil will be returned
///   </li>
/// </ul>
+ (LPUserEntity * _Nullable)getUserFromDatabaseWithUserID:(NSString * _Nonnull)userID SWIFT_WARN_UNUSED_RESULT;
/// Fetching the user profile (consumer or agent) from server and update in database received details and current date as lastUpdated
/// Fetch will be performed in the following cases:
/// <ol>
///   <li>
///     User was never fetched
///   </li>
///   <li>
///     User was not fetched in current app run
///   </li>
///   <li>
///     User was not fetched for more than 24Hrs
///   </li>
/// </ol>
+ (void)refreshUserProfileWithBrandID:(NSString * _Nonnull)brandID user:(LPUserEntity * _Nonnull)user;
/// Get default agent user from DB
/// If there is no agent user in db, a new instance will be created and saved to db with default values
+ (LPUserEntity * _Nonnull)getDefaultAgentUserFromDB:(NSString * _Nonnull)senderId SWIFT_WARN_UNUSED_RESULT;
/// Set token for Pusher service in order to be able to receive remote push notifications
/// Optional - alternateBundleID, set custom bundle ID for Pusher with for the token
+ (void)setPusherTokenWithToken:(NSData * _Nonnull)token alternateBundleID:(NSString * _Nullable)alternateBundleID;
/// Register pusher with push notification token received from APNS (Apple).
/// Before registering the Pusher, we make sure have the following params:
/// <ul>
///   <li>
///     Consumer UserID
///   </li>
///   <li>
///     Push Token from Apple
///   </li>
///   <li>
///     CSDS Domain for Pusher
///   </li>
///   <li>
///     Account (brand account)
///     When all params availble - peform register
///   </li>
/// </ul>
+ (void)registerPusher:(LPBrandEntity * _Nonnull)brand;
/// Unregister pusher.
/// Before unregistering the Pusher, we make sure we have the following params:
/// <ul>
///   <li>
///     Consumer UserID
///   </li>
///   <li>
///     CSDS Domain for Pusher
///   </li>
///   <li>
///     Account (brand account)
///     When all params availble - peform unregister
///   </li>
/// </ul>
+ (void)unregisterPusher:(LPBrandEntity * _Nonnull)brand;
/// Load image from URL from a server or from the images cache manager
+ (void)loadImageFromURLWithImageUrl:(NSString * _Nullable)imageUrl completion:(void (^ _Nonnull)(UIImage * _Nullable, BOOL))completion failure:(void (^ _Nullable)(void))failure;
/// Set image for URL in images cache
+ (void)setImageByURL:(UIImage * _Nonnull)image url:(NSString * _Nonnull)url;
/// Get image by URL from images cache
+ (UIImage * _Nullable)getImageByURL:(NSString * _Nonnull)url SWIFT_WARN_UNUSED_RESULT;
/// Determine if network is reachable using reachability framework
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL isNetworkReachable;)
+ (BOOL)isNetworkReachable SWIFT_WARN_UNUSED_RESULT;
/// Gets structure content messages with a state of “loading”
///
/// returns:
/// Optional array of messages
+ (NSArray<LPMessageEntity *> * _Nullable)getLoadingStructureContentMessages SWIFT_WARN_UNUSED_RESULT;
/// Gets structure content boards with a state of “loading”
///
/// returns:
/// Optional array of custom boards
+ (NSArray<LPCustomItemEntity *> * _Nullable)getLoadingStructureContentCustomItems SWIFT_WARN_UNUSED_RESULT;
@end


/// We use this protocol as a mirror for LPAMSFacadeDelegate When setting delegate for LPMessagingAPIDelegate we just pass it as LPAMSFacadeDelegate to LPAMSFacade. Note: Before adding new methods this LPMessagingAPIDelegate but not to LPAMSFacadeDelegate, you should Implement LPAMSFacadeDelegate in this class and then call the delegate of LPMessagingAPIDelegate
SWIFT_PROTOCOL("_TtP14LPMessagingSDK22LPMessagingAPIDelegate_")
@protocol LPMessagingAPIDelegate <LPAMSFacadeDelegate>
@end

@protocol LPMessagingSDKdelegate;
@class UIViewController;
@class UIBarButtonItem;
@class LPLog;

SWIFT_CLASS("_TtC14LPMessagingSDK14LPMessagingSDK")
@interface LPMessagingSDK : NSObject <UINavigationControllerDelegate>
@property (nonatomic, weak) id <LPMessagingSDKdelegate> _Nullable delegate;
@property (nonatomic, weak) id <LPMessagingSDKNotificationDelegate> _Nullable notificationDelegate;
@property (nonatomic, copy) NSString * _Nullable accountID;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) LPMessagingSDK * _Nonnull instance;)
+ (LPMessagingSDK * _Nonnull)instance SWIFT_WARN_UNUSED_RESULT;
/// Initialize the SDK and all of its components.
/// Optional paramaters:
/// <brandID> of the host app.
/// This method throws an error/return false with with an error, in case the initialization failed.
- (BOOL)initialize:(NSString * _Nullable)brandID error:(NSError * _Nullable * _Nullable)error;
/// Show conversation view for conversation query.
/// This method starts the conversation and show all the existing messages it exist.
/// Optional paramaters:
/// <authenticationCode> to use an an authenticated users.
/// <containerViewController> the containter which presents the conversation view as a child View Controller.
- (void)showConversation:(id <ConversationParamProtocol> _Nonnull)conversationQuery authenticationCode:(NSString * _Nullable)authenticationCode containerViewController:(UIViewController * _Nullable)containerViewController;
/// Remove conversation view for conversation query from its container or window view.
/// This method ends the conversation’s connection.
- (void)removeConversation:(id <ConversationParamProtocol> _Nonnull)conversationQuery;
/// This method reconnects the conversation’s connection for conversation query.
/// Reconnect open related webSockets and sync the converstion with its latest updates.
/// Additional paramaters:
/// <authenticationCode> to use an an authenticated users.
- (void)reconnect:(id <ConversationParamProtocol> _Nonnull)conversationQuery authenticationCode:(NSString * _Nonnull)authenticationCode;
/// This method changes the state of the action menu of the conversation for brandID.
- (void)toggleChatActions:(NSString * _Nonnull)accountID sender:(UIBarButtonItem * _Nullable)sender;
/// This method sets user details for the consumer of a brand.
/// The user object is in Type of LPUser which includes all the user details.
/// Additional paramaters:
/// <brandID> is the brand of the related user.
/// If the SDK is not connected, it’ll save the last user for each brand, until connected.
- (void)setUserProfile:(LPUser * _Nonnull)lpuser brandID:(NSString * _Nonnull)brandID;
/// This method passes a user info of a remote push notification to be handled by the SDK.
- (void)handlePush:(NSDictionary * _Nonnull)userInfo;
/// This method registers the host app in the SDK Pusher service in order to be able to receive push notification in messaging.
/// Optional paramaters:
/// <notificationDelegate> is the implementer of LPMessagingSDKNotificationDelegate.
/// <alternateBundleID> is a value for using in order to let the Pusher service to identify the host app with this bundle identifier.
- (void)registerPushNotificationsWithToken:(NSData * _Nonnull)token notificationDelegate:(id <LPMessagingSDKNotificationDelegate> _Nullable)notificationDelegate alternateBundleID:(NSString * _Nullable)alternateBundleID;
/// This method created ConversationParamProtocol of Brand query type.
- (id <ConversationParamProtocol> _Nonnull)getConversationBrandQuery:(NSString * _Nonnull)brandID SWIFT_WARN_UNUSED_RESULT;
/// This method created ConversationParamProtocol of Brand and Skill query type.
- (id <ConversationParamProtocol> _Nonnull)getConversationBrandAndSkillQuery:(NSString * _Nonnull)brandID skillID:(NSString * _Nonnull)skillID SWIFT_WARN_UNUSED_RESULT;
/// This method created ConversationParamProtocol of Consumer and Skill query type.
- (id <ConversationParamProtocol> _Nonnull)getConversationConsumerQuery:(NSString * _Nullable)consumerID brandID:(NSString * _Nonnull)brandID agentToken:(NSString * _Nonnull)agentToken SWIFT_WARN_UNUSED_RESULT;
/// This method checks for an active(Open/Created) conversation according to conversation query.
/// Return value:
/// True - there is an active conversation.
/// False - there is no active conversation.
- (BOOL)checkActiveConversation:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// DEPRECATED - This method sets a custom image for the custom button in the conversation navigationBar.
/// Use customButtonImage instead
- (void)setCustomButton:(UIImage * _Nullable)image;
/// This method checks if the active conversation of a conversation query marked as Urgent.
/// Return value:
/// True - conversation is marked as Urgent.
/// False - conversation is not marked as Urgent.
- (BOOL)isUrgent:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// This method marks the active conversation of a conversation query as Urgent.
- (void)markAsUrgent:(id <ConversationParamProtocol> _Nonnull)conversationQuery;
/// This method dismisses the active conversation from Urgent to Normal.
- (void)dismissUrgent:(id <ConversationParamProtocol> _Nonnull)conversationQuery;
/// This method ends the active conversation if exists.
- (void)resolveConversation:(id <ConversationParamProtocol> _Nonnull)conversationQuery;
/// This methods returns the assigned agent of the active or the latest closed conversation, if exists.
- (LPUser * _Nullable)getAssignedAgent:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
/// This method determines wether a brandID is Ready.
/// Ready means that the brand is connected and conversation can be proccessed.
- (BOOL)isBrandReady:(NSString * _Nonnull)brandID SWIFT_WARN_UNUSED_RESULT;
/// This method returns the SDK version.
- (NSString * _Nullable)getSDKVersion SWIFT_WARN_UNUSED_RESULT;
/// This method deletes all the messages and closed conversation of the related conversation query.
/// This method throws an error if the conversations history failed to cleared.
/// Note: clear history is allowed only if there is no open/active conversation related to the passed conversation query.
- (BOOL)clearHistory:(id <ConversationParamProtocol> _Nonnull)conversationQuery error:(NSError * _Nullable * _Nullable)error;
/// This method subscribes the host app to recieve log events from a specific log level and above.
/// Optionl log levels: TRACE, DEBUG, INFO, WARNING and ERROR.
/// The completion block will pass LPLog object which consists all the information for the log.
- (void)subscribeLogEvents:(enum LogLevel)logLevel logEvent:(void (^ _Nonnull)(LPLog * _Nonnull))logEvent;
/// Prints all localized string’s keys
- (void)printAllLocalizedKeys;
/// Prints the SDK supported languages
- (void)printSupportedLanguages;
/// Get all supported languages as Strings dictionary where:
/// Key - Locale key
/// Value - explicit language name (example: “English”, “Portuguese (Brazil)”, …)
- (NSDictionary<NSString *, NSString *> * _Nonnull)getAllSupportedLanguages SWIFT_WARN_UNUSED_RESULT;
@end


@interface LPMessagingSDK (SWIFT_EXTENSION(LPMessagingSDK))
@end


@interface LPMessagingSDK (SWIFT_EXTENSION(LPMessagingSDK))
- (void)initSocketForBrandID:(NSString * _Nonnull)brandID agentToken:(NSString * _Nonnull)agentToken readyCompletion:(void (^ _Nullable)(void))readyCompletion SWIFT_METHOD_FAMILY(none);
- (id <ConversationViewControllerAgentDelegate> _Nonnull)showAgentConversation:(id <ConversationParamProtocol> _Nonnull)conversationQuery authenticationCode:(NSString * _Nullable)authenticationCode containerViewController:(UIViewController * _Nonnull)containerViewController SWIFT_WARN_UNUSED_RESULT;
@end


@interface LPMessagingSDK (SWIFT_EXTENSION(LPMessagingSDK))
@end


@interface LPMessagingSDK (SWIFT_EXTENSION(LPMessagingSDK))
- (void)logout;
- (void)destruct;
@end

@class LPNotification;
@class UIView;

SWIFT_PROTOCOL("_TtP14LPMessagingSDK34LPMessagingSDKNotificationDelegate_")
@protocol LPMessagingSDKNotificationDelegate
@optional
- (void)LPMessagingSDKNotificationWithDidReceivePushNotification:(LPNotification * _Nonnull)notification;
- (BOOL)LPMessagingSDKNotificationWithShouldShowPushNotification:(LPNotification * _Nonnull)notification SWIFT_WARN_UNUSED_RESULT;
- (UIView * _Nonnull)LPMessagingSDKNotificationWithCustomLocalPushNotificationView:(LPNotification * _Nonnull)notification SWIFT_WARN_UNUSED_RESULT;
- (void)LPMessagingSDKNotificationWithNotificationTapped:(LPNotification * _Nonnull)notification;
@end


SWIFT_PROTOCOL("_TtP14LPMessagingSDK22LPMessagingSDKdelegate_")
@protocol LPMessagingSDKdelegate
@optional
- (void)LPMessagingSDKCustomButtonTapped;
- (void)LPMessagingSDKAgentDetails:(LPUser * _Nullable)agent;
- (void)LPMessagingSDKAgentAvatarTapped:(LPUser * _Nullable)agent;
- (void)LPMessagingSDKActionsMenuToggled:(BOOL)toggled;
- (void)LPMessagingSDKHasConnectionError:(NSString * _Nullable)error;
- (void)LPMessagingSDKCSATScoreSubmissionDidFinish:(NSString * _Nonnull)brandID rating:(NSInteger)rating;
- (UIView * _Nonnull)LPMessagingSDKCSATCustomTitleView:(NSString * _Nonnull)brandID SWIFT_WARN_UNUSED_RESULT;
@required
- (void)LPMessagingSDKObseleteVersion:(NSError * _Nonnull)error;
- (void)LPMessagingSDKAuthenticationFailed:(NSError * _Nonnull)error;
- (void)LPMessagingSDKTokenExpired:(NSString * _Nonnull)brandID;
- (void)LPMessagingSDKError:(NSError * _Nonnull)error;
@optional
- (void)LPMessagingSDKAgentIsTypingStateChanged:(BOOL)isTyping;
- (void)LPMessagingSDKConversationStarted:(NSString * _Nullable)conversationID;
- (void)LPMessagingSDKConversationEnded:(NSString * _Nullable)conversationID;
- (void)LPMessagingSDKConversationEnded:(NSString * _Nullable)conversationID closeReason:(enum LPConversationCloseReason)closeReason;
- (void)LPMessagingSDKConversationCSATDismissedOnSubmittion:(NSString * _Nullable)conversationID;
- (void)LPMessagingSDKConnectionStateChanged:(BOOL)isReady brandID:(NSString * _Nonnull)brandID;
- (void)LPMessagingSDKOffHoursStateChanged:(BOOL)isOffHours brandID:(NSString * _Nonnull)brandID;
- (void)LPMessagingSDKConversationViewControllerDidDismiss;
@end


SWIFT_CLASS("_TtC14LPMessagingSDK14LPNotification")
@interface LPNotification : NSObject
@property (nonatomic, copy) NSString * _Nonnull text;
@property (nonatomic, strong) LPUser * _Nonnull user;
@property (nonatomic, copy) NSString * _Nonnull accountID;
@property (nonatomic) BOOL isRemote;
@property (nonatomic, readonly, copy) NSString * _Nonnull toString;
- (nonnull instancetype)initWithText:(NSString * _Nonnull)text firstName:(NSString * _Nullable)firstName lastName:(NSString * _Nullable)lastName uid:(NSString * _Nullable)uid accountID:(NSString * _Nonnull)accountID isRemote:(BOOL)isRemote;
- (nonnull instancetype)initWithMessage:(LPMessageEntity * _Nonnull)message isRemote:(BOOL)isRemote;
- (nonnull instancetype)initWithText:(NSString * _Nonnull)text user:(LPUser * _Nonnull)user accountID:(NSString * _Nonnull)accountID isRemote:(BOOL)isRemote OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

@class NSCoder;

SWIFT_CLASS("_TtC14LPMessagingSDK19LPRadialProgressBar")
@interface LPRadialProgressBar : UIView
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end

@class UIColor;

SWIFT_CLASS("_TtC14LPMessagingSDK12NSBouncyView")
@interface NSBouncyView : UIView
- (void)setView:(UIView * _Nonnull)view;
- (void)setColorWithColor:(UIColor * _Nonnull)color;
- (void)toggleVisibilityWithShow:(BOOL)show willStart:(void (^ _Nonnull)(void))willStart didComplete:(void (^ _Nonnull)(void))didComplete didFail:(void (^ _Nonnull)(void))didFail;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end


@interface NSLayoutConstraint (SWIFT_EXTENSION(LPMessagingSDK))
@end


SWIFT_CLASS("_TtC14LPMessagingSDK22RemoteUserIsTypingView")
@interface RemoteUserIsTypingView : UIView
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@class UITextView;
@class UIGestureRecognizer;

SWIFT_PROTOCOL("_TtP14LPMessagingSDK17UIAdapterDelegate_")
@protocol UIAdapterDelegate
@optional
- (BOOL)sendClickedWithMessage:(NSString * _Nonnull)message inConversation:(LPConversationEntity * _Nonnull)inConversation SWIFT_WARN_UNUSED_RESULT;
- (void)executeActionAtIndex:(UIViewController * _Nonnull)viewController index:(NSInteger)index conversation:(LPConversationEntity * _Nullable)conversation complition:(SWIFT_NOESCAPE void (^ _Nonnull)(void))complition;
- (void)textViewDidBeginEditingWithConversation:(LPConversationEntity * _Nullable)conversation;
- (void)textViewDidEndEditingWithConversation:(LPConversationEntity * _Nullable)conversation;
- (BOOL)textView:(UITextView * _Nonnull)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString * _Nonnull)text conversation:(LPConversationEntity * _Nullable)conversation SWIFT_WARN_UNUSED_RESULT;
- (BOOL)shouldSetUIReadOnly:(LPConversationEntity * _Nullable)conversation SWIFT_WARN_UNUSED_RESULT;
- (UIColor * _Nonnull)getTableViewBackgroundColor:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
- (UIImage * _Nonnull)getDefaultRecepientAvatarImage:(id <ConversationParamProtocol> _Nonnull)conversationQuery SWIFT_WARN_UNUSED_RESULT;
- (UIGestureRecognizer * _Nonnull)getTableViewCustomGestureRecognizer SWIFT_WARN_UNUSED_RESULT;
@end


@interface UIImageView (SWIFT_EXTENSION(LPMessagingSDK))
@end


@interface UITableView (SWIFT_EXTENSION(LPMessagingSDK))
@end


@interface UITableViewCell (SWIFT_EXTENSION(LPMessagingSDK))
@end


@interface UIView (SWIFT_EXTENSION(LPMessagingSDK))
- (void)shake;
/// Rotate UIImageView 360
/// \param imageView UIImageView to rotate
///
/// \param completion completionBlock which is invoked once the rotation finished. If it is neccessary to continue rotation, just call this method again from inside the block
///
+ (void)animateRotationFor:(UIImageView * _Nullable)imageView withDuration:(NSTimeInterval)duration completion:(void (^ _Nonnull)(void))completion;
/// Rotates a view
/// \param duration The amount of time to finish 1 rotation
///
/// \param repeatCount Number of times to rotate (Float.infinity for forever)
///
- (void)rotateWithDuration:(double)duration repeatCount:(float)repeatCount;
@end


@interface UIView (SWIFT_EXTENSION(LPMessagingSDK))
@end

#pragma clang diagnostic pop
